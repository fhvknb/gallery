"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/viewerjs";
exports.ids = ["vendor-chunks/viewerjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/viewerjs/dist/viewer.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/viewerjs/dist/viewer.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Viewer)\n/* harmony export */ });\n/*!\n * Viewer.js v1.11.6\n * https://fengyuanchen.github.io/viewerjs\n *\n * Copyright 2015-present Chen Fengyuan\n * Released under the MIT license\n *\n * Date: 2023-09-17T03:16:38.052Z\n */\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar DEFAULTS = {\n  /**\n   * Enable a modal backdrop, specify `static` for a backdrop\n   * which doesn't close the modal on click.\n   * @type {boolean}\n   */\n  backdrop: true,\n  /**\n   * Show the button on the top-right of the viewer.\n   * @type {boolean}\n   */\n  button: true,\n  /**\n   * Show the navbar.\n   * @type {boolean | number}\n   */\n  navbar: true,\n  /**\n   * Specify the visibility and the content of the title.\n   * @type {boolean | number | Function | Array}\n   */\n  title: true,\n  /**\n   * Show the toolbar.\n   * @type {boolean | number | Object}\n   */\n  toolbar: true,\n  /**\n   * Custom class name(s) to add to the viewer's root element.\n   * @type {string}\n   */\n  className: '',\n  /**\n   * Define where to put the viewer in modal mode.\n   * @type {string | Element}\n   */\n  container: 'body',\n  /**\n   * Filter the images for viewing. Return true if the image is viewable.\n   * @type {Function}\n   */\n  filter: null,\n  /**\n   * Enable to request fullscreen when play.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/FullscreenOptions}\n   * @type {boolean|FullscreenOptions}\n   */\n  fullscreen: true,\n  /**\n   * Define the extra attributes to inherit from the original image.\n   * @type {Array}\n   */\n  inheritedAttributes: ['crossOrigin', 'decoding', 'isMap', 'loading', 'referrerPolicy', 'sizes', 'srcset', 'useMap'],\n  /**\n   * Define the initial coverage of the viewing image.\n   * @type {number}\n   */\n  initialCoverage: 0.9,\n  /**\n   * Define the initial index of the image for viewing.\n   * @type {number}\n   */\n  initialViewIndex: 0,\n  /**\n   * Enable inline mode.\n   * @type {boolean}\n   */\n  inline: false,\n  /**\n   * The amount of time to delay between automatically cycling an image when playing.\n   * @type {number}\n   */\n  interval: 5000,\n  /**\n   * Enable keyboard support.\n   * @type {boolean}\n   */\n  keyboard: true,\n  /**\n   * Focus the viewer when initialized.\n   * @type {boolean}\n   */\n  focus: true,\n  /**\n   * Indicate if show a loading spinner when load image or not.\n   * @type {boolean}\n   */\n  loading: true,\n  /**\n   * Indicate if enable loop viewing or not.\n   * @type {boolean}\n   */\n  loop: true,\n  /**\n   * Min width of the viewer in inline mode.\n   * @type {number}\n   */\n  minWidth: 200,\n  /**\n   * Min height of the viewer in inline mode.\n   * @type {number}\n   */\n  minHeight: 100,\n  /**\n   * Enable to move the image.\n   * @type {boolean}\n   */\n  movable: true,\n  /**\n   * Enable to rotate the image.\n   * @type {boolean}\n   */\n  rotatable: true,\n  /**\n   * Enable to scale the image.\n   * @type {boolean}\n   */\n  scalable: true,\n  /**\n   * Enable to zoom the image.\n   * @type {boolean}\n   */\n  zoomable: true,\n  /**\n   * Enable to zoom the current image by dragging on the touch screen.\n   * @type {boolean}\n   */\n  zoomOnTouch: true,\n  /**\n   * Enable to zoom the image by wheeling mouse.\n   * @type {boolean}\n   */\n  zoomOnWheel: true,\n  /**\n   * Enable to slide to the next or previous image by swiping on the touch screen.\n   * @type {boolean}\n   */\n  slideOnTouch: true,\n  /**\n   * Indicate if toggle the image size between its natural size\n   * and initial size when double click on the image or not.\n   * @type {boolean}\n   */\n  toggleOnDblclick: true,\n  /**\n   * Show the tooltip with image ratio (percentage) when zoom in or zoom out.\n   * @type {boolean}\n   */\n  tooltip: true,\n  /**\n   * Enable CSS3 Transition for some special elements.\n   * @type {boolean}\n   */\n  transition: true,\n  /**\n   * Define the CSS `z-index` value of viewer in modal mode.\n   * @type {number}\n   */\n  zIndex: 2015,\n  /**\n   * Define the CSS `z-index` value of viewer in inline mode.\n   * @type {number}\n   */\n  zIndexInline: 0,\n  /**\n   * Define the ratio when zoom the image by wheeling mouse.\n   * @type {number}\n   */\n  zoomRatio: 0.1,\n  /**\n   * Define the min ratio of the image when zoom out.\n   * @type {number}\n   */\n  minZoomRatio: 0.01,\n  /**\n   * Define the max ratio of the image when zoom in.\n   * @type {number}\n   */\n  maxZoomRatio: 100,\n  /**\n   * Define where to get the original image URL for viewing.\n   * @type {string | Function}\n   */\n  url: 'src',\n  /**\n   * Event shortcuts.\n   * @type {Function}\n   */\n  ready: null,\n  show: null,\n  shown: null,\n  hide: null,\n  hidden: null,\n  view: null,\n  viewed: null,\n  move: null,\n  moved: null,\n  rotate: null,\n  rotated: null,\n  scale: null,\n  scaled: null,\n  zoom: null,\n  zoomed: null,\n  play: null,\n  stop: null\n};\n\nvar TEMPLATE = '<div class=\"viewer-container\" tabindex=\"-1\" touch-action=\"none\">' + '<div class=\"viewer-canvas\"></div>' + '<div class=\"viewer-footer\">' + '<div class=\"viewer-title\"></div>' + '<div class=\"viewer-toolbar\"></div>' + '<div class=\"viewer-navbar\">' + '<ul class=\"viewer-list\" role=\"navigation\"></ul>' + '</div>' + '</div>' + '<div class=\"viewer-tooltip\" role=\"alert\" aria-hidden=\"true\"></div>' + '<div class=\"viewer-button\" data-viewer-action=\"mix\" role=\"button\"></div>' + '<div class=\"viewer-player\"></div>' + '</div>';\n\nvar IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';\nvar WINDOW = IS_BROWSER ? window : {};\nvar IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? 'ontouchstart' in WINDOW.document.documentElement : false;\nvar HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;\nvar NAMESPACE = 'viewer';\n\n// Actions\nvar ACTION_MOVE = 'move';\nvar ACTION_SWITCH = 'switch';\nvar ACTION_ZOOM = 'zoom';\n\n// Classes\nvar CLASS_ACTIVE = \"\".concat(NAMESPACE, \"-active\");\nvar CLASS_CLOSE = \"\".concat(NAMESPACE, \"-close\");\nvar CLASS_FADE = \"\".concat(NAMESPACE, \"-fade\");\nvar CLASS_FIXED = \"\".concat(NAMESPACE, \"-fixed\");\nvar CLASS_FULLSCREEN = \"\".concat(NAMESPACE, \"-fullscreen\");\nvar CLASS_FULLSCREEN_EXIT = \"\".concat(NAMESPACE, \"-fullscreen-exit\");\nvar CLASS_HIDE = \"\".concat(NAMESPACE, \"-hide\");\nvar CLASS_HIDE_MD_DOWN = \"\".concat(NAMESPACE, \"-hide-md-down\");\nvar CLASS_HIDE_SM_DOWN = \"\".concat(NAMESPACE, \"-hide-sm-down\");\nvar CLASS_HIDE_XS_DOWN = \"\".concat(NAMESPACE, \"-hide-xs-down\");\nvar CLASS_IN = \"\".concat(NAMESPACE, \"-in\");\nvar CLASS_INVISIBLE = \"\".concat(NAMESPACE, \"-invisible\");\nvar CLASS_LOADING = \"\".concat(NAMESPACE, \"-loading\");\nvar CLASS_MOVE = \"\".concat(NAMESPACE, \"-move\");\nvar CLASS_OPEN = \"\".concat(NAMESPACE, \"-open\");\nvar CLASS_SHOW = \"\".concat(NAMESPACE, \"-show\");\nvar CLASS_TRANSITION = \"\".concat(NAMESPACE, \"-transition\");\n\n// Native events\nvar EVENT_CLICK = 'click';\nvar EVENT_DBLCLICK = 'dblclick';\nvar EVENT_DRAG_START = 'dragstart';\nvar EVENT_FOCUSIN = 'focusin';\nvar EVENT_KEY_DOWN = 'keydown';\nvar EVENT_LOAD = 'load';\nvar EVENT_ERROR = 'error';\nvar EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';\nvar EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';\nvar EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';\nvar EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;\nvar EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;\nvar EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;\nvar EVENT_RESIZE = 'resize';\nvar EVENT_TRANSITION_END = 'transitionend';\nvar EVENT_WHEEL = 'wheel';\n\n// Custom events\nvar EVENT_READY = 'ready';\nvar EVENT_SHOW = 'show';\nvar EVENT_SHOWN = 'shown';\nvar EVENT_HIDE = 'hide';\nvar EVENT_HIDDEN = 'hidden';\nvar EVENT_VIEW = 'view';\nvar EVENT_VIEWED = 'viewed';\nvar EVENT_MOVE = 'move';\nvar EVENT_MOVED = 'moved';\nvar EVENT_ROTATE = 'rotate';\nvar EVENT_ROTATED = 'rotated';\nvar EVENT_SCALE = 'scale';\nvar EVENT_SCALED = 'scaled';\nvar EVENT_ZOOM = 'zoom';\nvar EVENT_ZOOMED = 'zoomed';\nvar EVENT_PLAY = 'play';\nvar EVENT_STOP = 'stop';\n\n// Data keys\nvar DATA_ACTION = \"\".concat(NAMESPACE, \"Action\");\n\n// RegExps\nvar REGEXP_SPACES = /\\s\\s*/;\n\n// Misc\nvar BUTTONS = ['zoom-in', 'zoom-out', 'one-to-one', 'reset', 'prev', 'play', 'next', 'rotate-left', 'rotate-right', 'flip-horizontal', 'flip-vertical'];\n\n/**\n * Check if the given value is a string.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a string, else `false`.\n */\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\n/**\n * Check if the given value is not a number.\n */\nvar isNaN = Number.isNaN || WINDOW.isNaN;\n\n/**\n * Check if the given value is a number.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a number, else `false`.\n */\nfunction isNumber(value) {\n  return typeof value === 'number' && !isNaN(value);\n}\n\n/**\n * Check if the given value is undefined.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is undefined, else `false`.\n */\nfunction isUndefined(value) {\n  return typeof value === 'undefined';\n}\n\n/**\n * Check if the given value is an object.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is an object, else `false`.\n */\nfunction isObject(value) {\n  return _typeof(value) === 'object' && value !== null;\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Check if the given value is a plain object.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.\n */\nfunction isPlainObject(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  try {\n    var _constructor = value.constructor;\n    var prototype = _constructor.prototype;\n    return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Check if the given value is a function.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a function, else `false`.\n */\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\n/**\n * Iterate the given data.\n * @param {*} data - The data to iterate.\n * @param {Function} callback - The process function for each element.\n * @returns {*} The original data.\n */\nfunction forEach(data, callback) {\n  if (data && isFunction(callback)) {\n    if (Array.isArray(data) || isNumber(data.length) /* array-like */) {\n      var length = data.length;\n      var i;\n      for (i = 0; i < length; i += 1) {\n        if (callback.call(data, data[i], i, data) === false) {\n          break;\n        }\n      }\n    } else if (isObject(data)) {\n      Object.keys(data).forEach(function (key) {\n        callback.call(data, data[key], key, data);\n      });\n    }\n  }\n  return data;\n}\n\n/**\n * Extend the given object.\n * @param {*} obj - The object to be extended.\n * @param {*} args - The rest objects which will be merged to the first object.\n * @returns {Object} The extended object.\n */\nvar assign = Object.assign || function assign(obj) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  if (isObject(obj) && args.length > 0) {\n    args.forEach(function (arg) {\n      if (isObject(arg)) {\n        Object.keys(arg).forEach(function (key) {\n          obj[key] = arg[key];\n        });\n      }\n    });\n  }\n  return obj;\n};\nvar REGEXP_SUFFIX = /^(?:width|height|left|top|marginLeft|marginTop)$/;\n\n/**\n * Apply styles to the given element.\n * @param {Element} element - The target element.\n * @param {Object} styles - The styles for applying.\n */\nfunction setStyle(element, styles) {\n  var style = element.style;\n  forEach(styles, function (value, property) {\n    if (REGEXP_SUFFIX.test(property) && isNumber(value)) {\n      value += 'px';\n    }\n    style[property] = value;\n  });\n}\n\n/**\n * Escape a string for using in HTML.\n * @param {String} value - The string to escape.\n * @returns {String} Returns the escaped string.\n */\nfunction escapeHTMLEntities(value) {\n  return isString(value) ? value.replace(/&(?!amp;|quot;|#39;|lt;|gt;)/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : value;\n}\n\n/**\n * Check if the given element has a special class.\n * @param {Element} element - The element to check.\n * @param {string} value - The class to search.\n * @returns {boolean} Returns `true` if the special class was found.\n */\nfunction hasClass(element, value) {\n  if (!element || !value) {\n    return false;\n  }\n  return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;\n}\n\n/**\n * Add classes to the given element.\n * @param {Element} element - The target element.\n * @param {string} value - The classes to be added.\n */\nfunction addClass(element, value) {\n  if (!element || !value) {\n    return;\n  }\n  if (isNumber(element.length)) {\n    forEach(element, function (elem) {\n      addClass(elem, value);\n    });\n    return;\n  }\n  if (element.classList) {\n    element.classList.add(value);\n    return;\n  }\n  var className = element.className.trim();\n  if (!className) {\n    element.className = value;\n  } else if (className.indexOf(value) < 0) {\n    element.className = \"\".concat(className, \" \").concat(value);\n  }\n}\n\n/**\n * Remove classes from the given element.\n * @param {Element} element - The target element.\n * @param {string} value - The classes to be removed.\n */\nfunction removeClass(element, value) {\n  if (!element || !value) {\n    return;\n  }\n  if (isNumber(element.length)) {\n    forEach(element, function (elem) {\n      removeClass(elem, value);\n    });\n    return;\n  }\n  if (element.classList) {\n    element.classList.remove(value);\n    return;\n  }\n  if (element.className.indexOf(value) >= 0) {\n    element.className = element.className.replace(value, '');\n  }\n}\n\n/**\n * Add or remove classes from the given element.\n * @param {Element} element - The target element.\n * @param {string} value - The classes to be toggled.\n * @param {boolean} added - Add only.\n */\nfunction toggleClass(element, value, added) {\n  if (!value) {\n    return;\n  }\n  if (isNumber(element.length)) {\n    forEach(element, function (elem) {\n      toggleClass(elem, value, added);\n    });\n    return;\n  }\n\n  // IE10-11 doesn't support the second parameter of `classList.toggle`\n  if (added) {\n    addClass(element, value);\n  } else {\n    removeClass(element, value);\n  }\n}\nvar REGEXP_HYPHENATE = /([a-z\\d])([A-Z])/g;\n\n/**\n * Transform the given string from camelCase to kebab-case\n * @param {string} value - The value to transform.\n * @returns {string} The transformed value.\n */\nfunction hyphenate(value) {\n  return value.replace(REGEXP_HYPHENATE, '$1-$2').toLowerCase();\n}\n\n/**\n * Get data from the given element.\n * @param {Element} element - The target element.\n * @param {string} name - The data key to get.\n * @returns {string} The data value.\n */\nfunction getData(element, name) {\n  if (isObject(element[name])) {\n    return element[name];\n  }\n  if (element.dataset) {\n    return element.dataset[name];\n  }\n  return element.getAttribute(\"data-\".concat(hyphenate(name)));\n}\n\n/**\n * Set data to the given element.\n * @param {Element} element - The target element.\n * @param {string} name - The data key to set.\n * @param {string} data - The data value.\n */\nfunction setData(element, name, data) {\n  if (isObject(data)) {\n    element[name] = data;\n  } else if (element.dataset) {\n    element.dataset[name] = data;\n  } else {\n    element.setAttribute(\"data-\".concat(hyphenate(name)), data);\n  }\n}\nvar onceSupported = function () {\n  var supported = false;\n  if (IS_BROWSER) {\n    var once = false;\n    var listener = function listener() {};\n    var options = Object.defineProperty({}, 'once', {\n      get: function get() {\n        supported = true;\n        return once;\n      },\n      /**\n       * This setter can fix a `TypeError` in strict mode\n       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}\n       * @param {boolean} value - The value to set\n       */\n      set: function set(value) {\n        once = value;\n      }\n    });\n    WINDOW.addEventListener('test', listener, options);\n    WINDOW.removeEventListener('test', listener, options);\n  }\n  return supported;\n}();\n\n/**\n * Remove event listener from the target element.\n * @param {Element} element - The event target.\n * @param {string} type - The event type(s).\n * @param {Function} listener - The event listener.\n * @param {Object} options - The event options.\n */\nfunction removeListener(element, type, listener) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var handler = listener;\n  type.trim().split(REGEXP_SPACES).forEach(function (event) {\n    if (!onceSupported) {\n      var listeners = element.listeners;\n      if (listeners && listeners[event] && listeners[event][listener]) {\n        handler = listeners[event][listener];\n        delete listeners[event][listener];\n        if (Object.keys(listeners[event]).length === 0) {\n          delete listeners[event];\n        }\n        if (Object.keys(listeners).length === 0) {\n          delete element.listeners;\n        }\n      }\n    }\n    element.removeEventListener(event, handler, options);\n  });\n}\n\n/**\n * Add event listener to the target element.\n * @param {Element} element - The event target.\n * @param {string} type - The event type(s).\n * @param {Function} listener - The event listener.\n * @param {Object} options - The event options.\n */\nfunction addListener(element, type, listener) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _handler = listener;\n  type.trim().split(REGEXP_SPACES).forEach(function (event) {\n    if (options.once && !onceSupported) {\n      var _element$listeners = element.listeners,\n        listeners = _element$listeners === void 0 ? {} : _element$listeners;\n      _handler = function handler() {\n        delete listeners[event][listener];\n        element.removeEventListener(event, _handler, options);\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        listener.apply(element, args);\n      };\n      if (!listeners[event]) {\n        listeners[event] = {};\n      }\n      if (listeners[event][listener]) {\n        element.removeEventListener(event, listeners[event][listener], options);\n      }\n      listeners[event][listener] = _handler;\n      element.listeners = listeners;\n    }\n    element.addEventListener(event, _handler, options);\n  });\n}\n\n/**\n * Dispatch event on the target element.\n * @param {Element} element - The event target.\n * @param {string} type - The event type(s).\n * @param {Object} data - The additional event data.\n * @param {Object} options - The additional event options.\n * @returns {boolean} Indicate if the event is default prevented or not.\n */\nfunction dispatchEvent(element, type, data, options) {\n  var event;\n\n  // Event and CustomEvent on IE9-11 are global objects, not constructors\n  if (isFunction(Event) && isFunction(CustomEvent)) {\n    event = new CustomEvent(type, _objectSpread2({\n      bubbles: true,\n      cancelable: true,\n      detail: data\n    }, options));\n  } else {\n    event = document.createEvent('CustomEvent');\n    event.initCustomEvent(type, true, true, data);\n  }\n  return element.dispatchEvent(event);\n}\n\n/**\n * Get the offset base on the document.\n * @param {Element} element - The target element.\n * @returns {Object} The offset data.\n */\nfunction getOffset(element) {\n  var box = element.getBoundingClientRect();\n  return {\n    left: box.left + (window.pageXOffset - document.documentElement.clientLeft),\n    top: box.top + (window.pageYOffset - document.documentElement.clientTop)\n  };\n}\n\n/**\n * Get transforms base on the given object.\n * @param {Object} obj - The target object.\n * @returns {string} A string contains transform values.\n */\nfunction getTransforms(_ref) {\n  var rotate = _ref.rotate,\n    scaleX = _ref.scaleX,\n    scaleY = _ref.scaleY,\n    translateX = _ref.translateX,\n    translateY = _ref.translateY;\n  var values = [];\n  if (isNumber(translateX) && translateX !== 0) {\n    values.push(\"translateX(\".concat(translateX, \"px)\"));\n  }\n  if (isNumber(translateY) && translateY !== 0) {\n    values.push(\"translateY(\".concat(translateY, \"px)\"));\n  }\n\n  // Rotate should come first before scale to match orientation transform\n  if (isNumber(rotate) && rotate !== 0) {\n    values.push(\"rotate(\".concat(rotate, \"deg)\"));\n  }\n  if (isNumber(scaleX) && scaleX !== 1) {\n    values.push(\"scaleX(\".concat(scaleX, \")\"));\n  }\n  if (isNumber(scaleY) && scaleY !== 1) {\n    values.push(\"scaleY(\".concat(scaleY, \")\"));\n  }\n  var transform = values.length ? values.join(' ') : 'none';\n  return {\n    WebkitTransform: transform,\n    msTransform: transform,\n    transform: transform\n  };\n}\n\n/**\n * Get an image name from an image url.\n * @param {string} url - The target url.\n * @example\n * // picture.jpg\n * getImageNameFromURL('https://domain.com/path/to/picture.jpg?size=1280Ã—960')\n * @returns {string} A string contains the image name.\n */\nfunction getImageNameFromURL(url) {\n  return isString(url) ? decodeURIComponent(url.replace(/^.*\\//, '').replace(/[?&#].*$/, '')) : '';\n}\nvar IS_SAFARI = WINDOW.navigator && /Version\\/\\d+(\\.\\d+)+?\\s+Safari/i.test(WINDOW.navigator.userAgent);\n\n/**\n * Get an image's natural sizes.\n * @param {string} image - The target image.\n * @param {Object} options - The viewer options.\n * @param {Function} callback - The callback function.\n * @returns {HTMLImageElement} The new image.\n */\nfunction getImageNaturalSizes(image, options, callback) {\n  var newImage = document.createElement('img');\n\n  // Modern browsers (except Safari)\n  if (image.naturalWidth && !IS_SAFARI) {\n    callback(image.naturalWidth, image.naturalHeight);\n    return newImage;\n  }\n  var body = document.body || document.documentElement;\n  newImage.onload = function () {\n    callback(newImage.width, newImage.height);\n    if (!IS_SAFARI) {\n      body.removeChild(newImage);\n    }\n  };\n  forEach(options.inheritedAttributes, function (name) {\n    var value = image.getAttribute(name);\n    if (value !== null) {\n      newImage.setAttribute(name, value);\n    }\n  });\n  newImage.src = image.src;\n\n  // iOS Safari will convert the image automatically\n  // with its orientation once append it into DOM\n  if (!IS_SAFARI) {\n    newImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';\n    body.appendChild(newImage);\n  }\n  return newImage;\n}\n\n/**\n * Get the related class name of a responsive type number.\n * @param {string} type - The responsive type.\n * @returns {string} The related class name.\n */\nfunction getResponsiveClass(type) {\n  switch (type) {\n    case 2:\n      return CLASS_HIDE_XS_DOWN;\n    case 3:\n      return CLASS_HIDE_SM_DOWN;\n    case 4:\n      return CLASS_HIDE_MD_DOWN;\n    default:\n      return '';\n  }\n}\n\n/**\n * Get the max ratio of a group of pointers.\n * @param {string} pointers - The target pointers.\n * @returns {number} The result ratio.\n */\nfunction getMaxZoomRatio(pointers) {\n  var pointers2 = _objectSpread2({}, pointers);\n  var ratios = [];\n  forEach(pointers, function (pointer, pointerId) {\n    delete pointers2[pointerId];\n    forEach(pointers2, function (pointer2) {\n      var x1 = Math.abs(pointer.startX - pointer2.startX);\n      var y1 = Math.abs(pointer.startY - pointer2.startY);\n      var x2 = Math.abs(pointer.endX - pointer2.endX);\n      var y2 = Math.abs(pointer.endY - pointer2.endY);\n      var z1 = Math.sqrt(x1 * x1 + y1 * y1);\n      var z2 = Math.sqrt(x2 * x2 + y2 * y2);\n      var ratio = (z2 - z1) / z1;\n      ratios.push(ratio);\n    });\n  });\n  ratios.sort(function (a, b) {\n    return Math.abs(a) < Math.abs(b);\n  });\n  return ratios[0];\n}\n\n/**\n * Get a pointer from an event object.\n * @param {Object} event - The target event object.\n * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.\n * @returns {Object} The result pointer contains start and/or end point coordinates.\n */\nfunction getPointer(_ref2, endOnly) {\n  var pageX = _ref2.pageX,\n    pageY = _ref2.pageY;\n  var end = {\n    endX: pageX,\n    endY: pageY\n  };\n  return endOnly ? end : _objectSpread2({\n    timeStamp: Date.now(),\n    startX: pageX,\n    startY: pageY\n  }, end);\n}\n\n/**\n * Get the center point coordinate of a group of pointers.\n * @param {Object} pointers - The target pointers.\n * @returns {Object} The center point coordinate.\n */\nfunction getPointersCenter(pointers) {\n  var pageX = 0;\n  var pageY = 0;\n  var count = 0;\n  forEach(pointers, function (_ref3) {\n    var startX = _ref3.startX,\n      startY = _ref3.startY;\n    pageX += startX;\n    pageY += startY;\n    count += 1;\n  });\n  pageX /= count;\n  pageY /= count;\n  return {\n    pageX: pageX,\n    pageY: pageY\n  };\n}\n\nvar render = {\n  render: function render() {\n    this.initContainer();\n    this.initViewer();\n    this.initList();\n    this.renderViewer();\n  },\n  initBody: function initBody() {\n    var ownerDocument = this.element.ownerDocument;\n    var body = ownerDocument.body || ownerDocument.documentElement;\n    this.body = body;\n    this.scrollbarWidth = window.innerWidth - ownerDocument.documentElement.clientWidth;\n    this.initialBodyPaddingRight = body.style.paddingRight;\n    this.initialBodyComputedPaddingRight = window.getComputedStyle(body).paddingRight;\n  },\n  initContainer: function initContainer() {\n    this.containerData = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n  },\n  initViewer: function initViewer() {\n    var options = this.options,\n      parent = this.parent;\n    var viewerData;\n    if (options.inline) {\n      viewerData = {\n        width: Math.max(parent.offsetWidth, options.minWidth),\n        height: Math.max(parent.offsetHeight, options.minHeight)\n      };\n      this.parentData = viewerData;\n    }\n    if (this.fulled || !viewerData) {\n      viewerData = this.containerData;\n    }\n    this.viewerData = assign({}, viewerData);\n  },\n  renderViewer: function renderViewer() {\n    if (this.options.inline && !this.fulled) {\n      setStyle(this.viewer, this.viewerData);\n    }\n  },\n  initList: function initList() {\n    var _this = this;\n    var element = this.element,\n      options = this.options,\n      list = this.list;\n    var items = [];\n\n    // initList may be called in this.update, so should keep idempotent\n    list.innerHTML = '';\n    forEach(this.images, function (image, index) {\n      var src = image.src;\n      var alt = image.alt || getImageNameFromURL(src);\n      var url = _this.getImageURL(image);\n      if (src || url) {\n        var item = document.createElement('li');\n        var img = document.createElement('img');\n        forEach(options.inheritedAttributes, function (name) {\n          var value = image.getAttribute(name);\n          if (value !== null) {\n            img.setAttribute(name, value);\n          }\n        });\n        if (options.navbar) {\n          img.src = src || url;\n        }\n        img.alt = alt;\n        img.setAttribute('data-original-url', url || src);\n        item.setAttribute('data-index', index);\n        item.setAttribute('data-viewer-action', 'view');\n        item.setAttribute('role', 'button');\n        if (options.keyboard) {\n          item.setAttribute('tabindex', 0);\n        }\n        item.appendChild(img);\n        list.appendChild(item);\n        items.push(item);\n      }\n    });\n    this.items = items;\n    forEach(items, function (item) {\n      var image = item.firstElementChild;\n      var onLoad;\n      var onError;\n      setData(image, 'filled', true);\n      if (options.loading) {\n        addClass(item, CLASS_LOADING);\n      }\n      addListener(image, EVENT_LOAD, onLoad = function onLoad(event) {\n        removeListener(image, EVENT_ERROR, onError);\n        if (options.loading) {\n          removeClass(item, CLASS_LOADING);\n        }\n        _this.loadImage(event);\n      }, {\n        once: true\n      });\n      addListener(image, EVENT_ERROR, onError = function onError() {\n        removeListener(image, EVENT_LOAD, onLoad);\n        if (options.loading) {\n          removeClass(item, CLASS_LOADING);\n        }\n      }, {\n        once: true\n      });\n    });\n    if (options.transition) {\n      addListener(element, EVENT_VIEWED, function () {\n        addClass(list, CLASS_TRANSITION);\n      }, {\n        once: true\n      });\n    }\n  },\n  renderList: function renderList() {\n    var index = this.index;\n    var item = this.items[index];\n    if (!item) {\n      return;\n    }\n    var next = item.nextElementSibling;\n    var gutter = parseInt(window.getComputedStyle(next || item).marginLeft, 10);\n    var offsetWidth = item.offsetWidth;\n    var outerWidth = offsetWidth + gutter;\n\n    // Place the active item in the center of the screen\n    setStyle(this.list, assign({\n      width: outerWidth * this.length - gutter\n    }, getTransforms({\n      translateX: (this.viewerData.width - offsetWidth) / 2 - outerWidth * index\n    })));\n  },\n  resetList: function resetList() {\n    var list = this.list;\n    list.innerHTML = '';\n    removeClass(list, CLASS_TRANSITION);\n    setStyle(list, getTransforms({\n      translateX: 0\n    }));\n  },\n  initImage: function initImage(done) {\n    var _this2 = this;\n    var options = this.options,\n      image = this.image,\n      viewerData = this.viewerData;\n    var footerHeight = this.footer.offsetHeight;\n    var viewerWidth = viewerData.width;\n    var viewerHeight = Math.max(viewerData.height - footerHeight, footerHeight);\n    var oldImageData = this.imageData || {};\n    var sizingImage;\n    this.imageInitializing = {\n      abort: function abort() {\n        sizingImage.onload = null;\n      }\n    };\n    sizingImage = getImageNaturalSizes(image, options, function (naturalWidth, naturalHeight) {\n      var aspectRatio = naturalWidth / naturalHeight;\n      var initialCoverage = Math.max(0, Math.min(1, options.initialCoverage));\n      var width = viewerWidth;\n      var height = viewerHeight;\n      _this2.imageInitializing = false;\n      if (viewerHeight * aspectRatio > viewerWidth) {\n        height = viewerWidth / aspectRatio;\n      } else {\n        width = viewerHeight * aspectRatio;\n      }\n      initialCoverage = isNumber(initialCoverage) ? initialCoverage : 0.9;\n      width = Math.min(width * initialCoverage, naturalWidth);\n      height = Math.min(height * initialCoverage, naturalHeight);\n      var left = (viewerWidth - width) / 2;\n      var top = (viewerHeight - height) / 2;\n      var imageData = {\n        left: left,\n        top: top,\n        x: left,\n        y: top,\n        width: width,\n        height: height,\n        oldRatio: 1,\n        ratio: width / naturalWidth,\n        aspectRatio: aspectRatio,\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight\n      };\n      var initialImageData = assign({}, imageData);\n      if (options.rotatable) {\n        imageData.rotate = oldImageData.rotate || 0;\n        initialImageData.rotate = 0;\n      }\n      if (options.scalable) {\n        imageData.scaleX = oldImageData.scaleX || 1;\n        imageData.scaleY = oldImageData.scaleY || 1;\n        initialImageData.scaleX = 1;\n        initialImageData.scaleY = 1;\n      }\n      _this2.imageData = imageData;\n      _this2.initialImageData = initialImageData;\n      if (done) {\n        done();\n      }\n    });\n  },\n  renderImage: function renderImage(done) {\n    var _this3 = this;\n    var image = this.image,\n      imageData = this.imageData;\n    setStyle(image, assign({\n      width: imageData.width,\n      height: imageData.height,\n      // XXX: Not to use translateX/Y to avoid image shaking when zooming\n      marginLeft: imageData.x,\n      marginTop: imageData.y\n    }, getTransforms(imageData)));\n    if (done) {\n      if ((this.viewing || this.moving || this.rotating || this.scaling || this.zooming) && this.options.transition && hasClass(image, CLASS_TRANSITION)) {\n        var onTransitionEnd = function onTransitionEnd() {\n          _this3.imageRendering = false;\n          done();\n        };\n        this.imageRendering = {\n          abort: function abort() {\n            removeListener(image, EVENT_TRANSITION_END, onTransitionEnd);\n          }\n        };\n        addListener(image, EVENT_TRANSITION_END, onTransitionEnd, {\n          once: true\n        });\n      } else {\n        done();\n      }\n    }\n  },\n  resetImage: function resetImage() {\n    var image = this.image;\n    if (image) {\n      if (this.viewing) {\n        this.viewing.abort();\n      }\n      image.parentNode.removeChild(image);\n      this.image = null;\n      this.title.innerHTML = '';\n    }\n  }\n};\n\nvar events = {\n  bind: function bind() {\n    var options = this.options,\n      viewer = this.viewer,\n      canvas = this.canvas;\n    var document = this.element.ownerDocument;\n    addListener(viewer, EVENT_CLICK, this.onClick = this.click.bind(this));\n    addListener(viewer, EVENT_DRAG_START, this.onDragStart = this.dragstart.bind(this));\n    addListener(canvas, EVENT_POINTER_DOWN, this.onPointerDown = this.pointerdown.bind(this));\n    addListener(document, EVENT_POINTER_MOVE, this.onPointerMove = this.pointermove.bind(this));\n    addListener(document, EVENT_POINTER_UP, this.onPointerUp = this.pointerup.bind(this));\n    addListener(document, EVENT_KEY_DOWN, this.onKeyDown = this.keydown.bind(this));\n    addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));\n    if (options.zoomable && options.zoomOnWheel) {\n      addListener(viewer, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {\n        passive: false,\n        capture: true\n      });\n    }\n    if (options.toggleOnDblclick) {\n      addListener(canvas, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));\n    }\n  },\n  unbind: function unbind() {\n    var options = this.options,\n      viewer = this.viewer,\n      canvas = this.canvas;\n    var document = this.element.ownerDocument;\n    removeListener(viewer, EVENT_CLICK, this.onClick);\n    removeListener(viewer, EVENT_DRAG_START, this.onDragStart);\n    removeListener(canvas, EVENT_POINTER_DOWN, this.onPointerDown);\n    removeListener(document, EVENT_POINTER_MOVE, this.onPointerMove);\n    removeListener(document, EVENT_POINTER_UP, this.onPointerUp);\n    removeListener(document, EVENT_KEY_DOWN, this.onKeyDown);\n    removeListener(window, EVENT_RESIZE, this.onResize);\n    if (options.zoomable && options.zoomOnWheel) {\n      removeListener(viewer, EVENT_WHEEL, this.onWheel, {\n        passive: false,\n        capture: true\n      });\n    }\n    if (options.toggleOnDblclick) {\n      removeListener(canvas, EVENT_DBLCLICK, this.onDblclick);\n    }\n  }\n};\n\nvar handlers = {\n  click: function click(event) {\n    var options = this.options,\n      imageData = this.imageData;\n    var target = event.target;\n    var action = getData(target, DATA_ACTION);\n    if (!action && target.localName === 'img' && target.parentElement.localName === 'li') {\n      target = target.parentElement;\n      action = getData(target, DATA_ACTION);\n    }\n\n    // Cancel the emulated click when the native click event was triggered.\n    if (IS_TOUCH_DEVICE && event.isTrusted && target === this.canvas) {\n      clearTimeout(this.clickCanvasTimeout);\n    }\n    switch (action) {\n      case 'mix':\n        if (this.played) {\n          this.stop();\n        } else if (options.inline) {\n          if (this.fulled) {\n            this.exit();\n          } else {\n            this.full();\n          }\n        } else {\n          this.hide();\n        }\n        break;\n      case 'hide':\n        if (!this.pointerMoved) {\n          this.hide();\n        }\n        break;\n      case 'view':\n        this.view(getData(target, 'index'));\n        break;\n      case 'zoom-in':\n        this.zoom(0.1, true);\n        break;\n      case 'zoom-out':\n        this.zoom(-0.1, true);\n        break;\n      case 'one-to-one':\n        this.toggle();\n        break;\n      case 'reset':\n        this.reset();\n        break;\n      case 'prev':\n        this.prev(options.loop);\n        break;\n      case 'play':\n        this.play(options.fullscreen);\n        break;\n      case 'next':\n        this.next(options.loop);\n        break;\n      case 'rotate-left':\n        this.rotate(-90);\n        break;\n      case 'rotate-right':\n        this.rotate(90);\n        break;\n      case 'flip-horizontal':\n        this.scaleX(-imageData.scaleX || -1);\n        break;\n      case 'flip-vertical':\n        this.scaleY(-imageData.scaleY || -1);\n        break;\n      default:\n        if (this.played) {\n          this.stop();\n        }\n    }\n  },\n  dblclick: function dblclick(event) {\n    event.preventDefault();\n    if (this.viewed && event.target === this.image) {\n      // Cancel the emulated double click when the native dblclick event was triggered.\n      if (IS_TOUCH_DEVICE && event.isTrusted) {\n        clearTimeout(this.doubleClickImageTimeout);\n      }\n\n      // XXX: No pageX/Y properties in custom event, fallback to the original event.\n      this.toggle(event.isTrusted ? event : event.detail && event.detail.originalEvent);\n    }\n  },\n  load: function load() {\n    var _this = this;\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = false;\n    }\n    var element = this.element,\n      options = this.options,\n      image = this.image,\n      index = this.index,\n      viewerData = this.viewerData;\n    removeClass(image, CLASS_INVISIBLE);\n    if (options.loading) {\n      removeClass(this.canvas, CLASS_LOADING);\n    }\n    image.style.cssText = 'height:0;' + \"margin-left:\".concat(viewerData.width / 2, \"px;\") + \"margin-top:\".concat(viewerData.height / 2, \"px;\") + 'max-width:none!important;' + 'position:relative;' + 'width:0;';\n    this.initImage(function () {\n      toggleClass(image, CLASS_MOVE, options.movable);\n      toggleClass(image, CLASS_TRANSITION, options.transition);\n      _this.renderImage(function () {\n        _this.viewed = true;\n        _this.viewing = false;\n        if (isFunction(options.viewed)) {\n          addListener(element, EVENT_VIEWED, options.viewed, {\n            once: true\n          });\n        }\n        dispatchEvent(element, EVENT_VIEWED, {\n          originalImage: _this.images[index],\n          index: index,\n          image: image\n        }, {\n          cancelable: false\n        });\n      });\n    });\n  },\n  loadImage: function loadImage(event) {\n    var image = event.target;\n    var parent = image.parentNode;\n    var parentWidth = parent.offsetWidth || 30;\n    var parentHeight = parent.offsetHeight || 50;\n    var filled = !!getData(image, 'filled');\n    getImageNaturalSizes(image, this.options, function (naturalWidth, naturalHeight) {\n      var aspectRatio = naturalWidth / naturalHeight;\n      var width = parentWidth;\n      var height = parentHeight;\n      if (parentHeight * aspectRatio > parentWidth) {\n        if (filled) {\n          width = parentHeight * aspectRatio;\n        } else {\n          height = parentWidth / aspectRatio;\n        }\n      } else if (filled) {\n        height = parentWidth / aspectRatio;\n      } else {\n        width = parentHeight * aspectRatio;\n      }\n      setStyle(image, assign({\n        width: width,\n        height: height\n      }, getTransforms({\n        translateX: (parentWidth - width) / 2,\n        translateY: (parentHeight - height) / 2\n      })));\n    });\n  },\n  keydown: function keydown(event) {\n    var options = this.options;\n    if (!options.keyboard) {\n      return;\n    }\n    var keyCode = event.keyCode || event.which || event.charCode;\n    switch (keyCode) {\n      // Enter\n      case 13:\n        if (this.viewer.contains(event.target)) {\n          this.click(event);\n        }\n        break;\n    }\n    if (!this.fulled) {\n      return;\n    }\n    switch (keyCode) {\n      // Escape\n      case 27:\n        if (this.played) {\n          this.stop();\n        } else if (options.inline) {\n          if (this.fulled) {\n            this.exit();\n          }\n        } else {\n          this.hide();\n        }\n        break;\n\n      // Space\n      case 32:\n        if (this.played) {\n          this.stop();\n        }\n        break;\n\n      // ArrowLeft\n      case 37:\n        if (this.played && this.playing) {\n          this.playing.prev();\n        } else {\n          this.prev(options.loop);\n        }\n        break;\n\n      // ArrowUp\n      case 38:\n        // Prevent scroll on Firefox\n        event.preventDefault();\n\n        // Zoom in\n        this.zoom(options.zoomRatio, true);\n        break;\n\n      // ArrowRight\n      case 39:\n        if (this.played && this.playing) {\n          this.playing.next();\n        } else {\n          this.next(options.loop);\n        }\n        break;\n\n      // ArrowDown\n      case 40:\n        // Prevent scroll on Firefox\n        event.preventDefault();\n\n        // Zoom out\n        this.zoom(-options.zoomRatio, true);\n        break;\n\n      // Ctrl + 0\n      case 48:\n      // Fall through\n\n      // Ctrl + 1\n      // eslint-disable-next-line no-fallthrough\n      case 49:\n        if (event.ctrlKey) {\n          event.preventDefault();\n          this.toggle();\n        }\n        break;\n    }\n  },\n  dragstart: function dragstart(event) {\n    if (event.target.localName === 'img') {\n      event.preventDefault();\n    }\n  },\n  pointerdown: function pointerdown(event) {\n    var options = this.options,\n      pointers = this.pointers;\n    var buttons = event.buttons,\n      button = event.button;\n    this.pointerMoved = false;\n    if (!this.viewed || this.showing || this.viewing || this.hiding\n\n    // Handle mouse event and pointer event and ignore touch event\n    || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && (\n    // No primary button (Usually the left button)\n    isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0\n\n    // Open context menu\n    || event.ctrlKey)) {\n      return;\n    }\n\n    // Prevent default behaviours as page zooming in touch devices.\n    event.preventDefault();\n    if (event.changedTouches) {\n      forEach(event.changedTouches, function (touch) {\n        pointers[touch.identifier] = getPointer(touch);\n      });\n    } else {\n      pointers[event.pointerId || 0] = getPointer(event);\n    }\n    var action = options.movable ? ACTION_MOVE : false;\n    if (options.zoomOnTouch && options.zoomable && Object.keys(pointers).length > 1) {\n      action = ACTION_ZOOM;\n    } else if (options.slideOnTouch && (event.pointerType === 'touch' || event.type === 'touchstart') && this.isSwitchable()) {\n      action = ACTION_SWITCH;\n    }\n    if (options.transition && (action === ACTION_MOVE || action === ACTION_ZOOM)) {\n      removeClass(this.image, CLASS_TRANSITION);\n    }\n    this.action = action;\n  },\n  pointermove: function pointermove(event) {\n    var pointers = this.pointers,\n      action = this.action;\n    if (!this.viewed || !action) {\n      return;\n    }\n    event.preventDefault();\n    if (event.changedTouches) {\n      forEach(event.changedTouches, function (touch) {\n        assign(pointers[touch.identifier] || {}, getPointer(touch, true));\n      });\n    } else {\n      assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));\n    }\n    this.change(event);\n  },\n  pointerup: function pointerup(event) {\n    var _this2 = this;\n    var options = this.options,\n      action = this.action,\n      pointers = this.pointers;\n    var pointer;\n    if (event.changedTouches) {\n      forEach(event.changedTouches, function (touch) {\n        pointer = pointers[touch.identifier];\n        delete pointers[touch.identifier];\n      });\n    } else {\n      pointer = pointers[event.pointerId || 0];\n      delete pointers[event.pointerId || 0];\n    }\n    if (!action) {\n      return;\n    }\n    event.preventDefault();\n    if (options.transition && (action === ACTION_MOVE || action === ACTION_ZOOM)) {\n      addClass(this.image, CLASS_TRANSITION);\n    }\n    this.action = false;\n\n    // Emulate click and double click in touch devices to support backdrop and image zooming (#210).\n    if (IS_TOUCH_DEVICE && action !== ACTION_ZOOM && pointer && Date.now() - pointer.timeStamp < 500) {\n      clearTimeout(this.clickCanvasTimeout);\n      clearTimeout(this.doubleClickImageTimeout);\n      if (options.toggleOnDblclick && this.viewed && event.target === this.image) {\n        if (this.imageClicked) {\n          this.imageClicked = false;\n\n          // This timeout will be cleared later when a native dblclick event is triggering\n          this.doubleClickImageTimeout = setTimeout(function () {\n            dispatchEvent(_this2.image, EVENT_DBLCLICK, {\n              originalEvent: event\n            });\n          }, 50);\n        } else {\n          this.imageClicked = true;\n\n          // The default timing of a double click in Windows is 500 ms\n          this.doubleClickImageTimeout = setTimeout(function () {\n            _this2.imageClicked = false;\n          }, 500);\n        }\n      } else {\n        this.imageClicked = false;\n        if (options.backdrop && options.backdrop !== 'static' && event.target === this.canvas) {\n          // This timeout will be cleared later when a native click event is triggering\n          this.clickCanvasTimeout = setTimeout(function () {\n            dispatchEvent(_this2.canvas, EVENT_CLICK, {\n              originalEvent: event\n            });\n          }, 50);\n        }\n      }\n    }\n  },\n  resize: function resize() {\n    var _this3 = this;\n    if (!this.isShown || this.hiding) {\n      return;\n    }\n    if (this.fulled) {\n      this.close();\n      this.initBody();\n      this.open();\n    }\n    this.initContainer();\n    this.initViewer();\n    this.renderViewer();\n    this.renderList();\n    if (this.viewed) {\n      this.initImage(function () {\n        _this3.renderImage();\n      });\n    }\n    if (this.played) {\n      if (this.options.fullscreen && this.fulled && !(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {\n        this.stop();\n        return;\n      }\n      forEach(this.player.getElementsByTagName('img'), function (image) {\n        addListener(image, EVENT_LOAD, _this3.loadImage.bind(_this3), {\n          once: true\n        });\n        dispatchEvent(image, EVENT_LOAD);\n      });\n    }\n  },\n  wheel: function wheel(event) {\n    var _this4 = this;\n    if (!this.viewed) {\n      return;\n    }\n    event.preventDefault();\n\n    // Limit wheel speed to prevent zoom too fast\n    if (this.wheeling) {\n      return;\n    }\n    this.wheeling = true;\n    setTimeout(function () {\n      _this4.wheeling = false;\n    }, 50);\n    var ratio = Number(this.options.zoomRatio) || 0.1;\n    var delta = 1;\n    if (event.deltaY) {\n      delta = event.deltaY > 0 ? 1 : -1;\n    } else if (event.wheelDelta) {\n      delta = -event.wheelDelta / 120;\n    } else if (event.detail) {\n      delta = event.detail > 0 ? 1 : -1;\n    }\n    this.zoom(-delta * ratio, true, null, event);\n  }\n};\n\nvar methods = {\n  /** Show the viewer (only available in modal mode)\n   * @param {boolean} [immediate=false] - Indicates if show the viewer immediately or not.\n   * @returns {Viewer} this\n   */\n  show: function show() {\n    var immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var element = this.element,\n      options = this.options;\n    if (options.inline || this.showing || this.isShown || this.showing) {\n      return this;\n    }\n    if (!this.ready) {\n      this.build();\n      if (this.ready) {\n        this.show(immediate);\n      }\n      return this;\n    }\n    if (isFunction(options.show)) {\n      addListener(element, EVENT_SHOW, options.show, {\n        once: true\n      });\n    }\n    if (dispatchEvent(element, EVENT_SHOW) === false || !this.ready) {\n      return this;\n    }\n    if (this.hiding) {\n      this.transitioning.abort();\n    }\n    this.showing = true;\n    this.open();\n    var viewer = this.viewer;\n    removeClass(viewer, CLASS_HIDE);\n    viewer.setAttribute('role', 'dialog');\n    viewer.setAttribute('aria-labelledby', this.title.id);\n    viewer.setAttribute('aria-modal', true);\n    viewer.removeAttribute('aria-hidden');\n    if (options.transition && !immediate) {\n      var shown = this.shown.bind(this);\n      this.transitioning = {\n        abort: function abort() {\n          removeListener(viewer, EVENT_TRANSITION_END, shown);\n          removeClass(viewer, CLASS_IN);\n        }\n      };\n      addClass(viewer, CLASS_TRANSITION);\n\n      // Force reflow to enable CSS3 transition\n      viewer.initialOffsetWidth = viewer.offsetWidth;\n      addListener(viewer, EVENT_TRANSITION_END, shown, {\n        once: true\n      });\n      addClass(viewer, CLASS_IN);\n    } else {\n      addClass(viewer, CLASS_IN);\n      this.shown();\n    }\n    return this;\n  },\n  /**\n   * Hide the viewer (only available in modal mode)\n   * @param {boolean} [immediate=false] - Indicates if hide the viewer immediately or not.\n   * @returns {Viewer} this\n   */\n  hide: function hide() {\n    var _this = this;\n    var immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var element = this.element,\n      options = this.options;\n    if (options.inline || this.hiding || !(this.isShown || this.showing)) {\n      return this;\n    }\n    if (isFunction(options.hide)) {\n      addListener(element, EVENT_HIDE, options.hide, {\n        once: true\n      });\n    }\n    if (dispatchEvent(element, EVENT_HIDE) === false) {\n      return this;\n    }\n    if (this.showing) {\n      this.transitioning.abort();\n    }\n    this.hiding = true;\n    if (this.played) {\n      this.stop();\n    } else if (this.viewing) {\n      this.viewing.abort();\n    }\n    var viewer = this.viewer,\n      image = this.image;\n    var hideImmediately = function hideImmediately() {\n      removeClass(viewer, CLASS_IN);\n      _this.hidden();\n    };\n    if (options.transition && !immediate) {\n      var onViewerTransitionEnd = function onViewerTransitionEnd(event) {\n        // Ignore all propagating `transitionend` events (#275).\n        if (event && event.target === viewer) {\n          removeListener(viewer, EVENT_TRANSITION_END, onViewerTransitionEnd);\n          _this.hidden();\n        }\n      };\n      var onImageTransitionEnd = function onImageTransitionEnd() {\n        // In case of show the viewer by `viewer.show(true)` previously (#407).\n        if (hasClass(viewer, CLASS_TRANSITION)) {\n          addListener(viewer, EVENT_TRANSITION_END, onViewerTransitionEnd);\n          removeClass(viewer, CLASS_IN);\n        } else {\n          hideImmediately();\n        }\n      };\n      this.transitioning = {\n        abort: function abort() {\n          if (_this.viewed && hasClass(image, CLASS_TRANSITION)) {\n            removeListener(image, EVENT_TRANSITION_END, onImageTransitionEnd);\n          } else if (hasClass(viewer, CLASS_TRANSITION)) {\n            removeListener(viewer, EVENT_TRANSITION_END, onViewerTransitionEnd);\n          }\n        }\n      };\n\n      // In case of hiding the viewer when holding on the image (#255),\n      // note that the `CLASS_TRANSITION` class will be removed on pointer down.\n      if (this.viewed && hasClass(image, CLASS_TRANSITION)) {\n        addListener(image, EVENT_TRANSITION_END, onImageTransitionEnd, {\n          once: true\n        });\n        this.zoomTo(0, false, null, null, true);\n      } else {\n        onImageTransitionEnd();\n      }\n    } else {\n      hideImmediately();\n    }\n    return this;\n  },\n  /**\n   * View one of the images with image's index\n   * @param {number} index - The index of the image to view.\n   * @returns {Viewer} this\n   */\n  view: function view() {\n    var _this2 = this;\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.initialViewIndex;\n    index = Number(index) || 0;\n    if (this.hiding || this.played || index < 0 || index >= this.length || this.viewed && index === this.index) {\n      return this;\n    }\n    if (!this.isShown) {\n      this.index = index;\n      return this.show();\n    }\n    if (this.viewing) {\n      this.viewing.abort();\n    }\n    var element = this.element,\n      options = this.options,\n      title = this.title,\n      canvas = this.canvas;\n    var item = this.items[index];\n    var img = item.querySelector('img');\n    var url = getData(img, 'originalUrl');\n    var alt = img.getAttribute('alt');\n    var image = document.createElement('img');\n    forEach(options.inheritedAttributes, function (name) {\n      var value = img.getAttribute(name);\n      if (value !== null) {\n        image.setAttribute(name, value);\n      }\n    });\n    image.src = url;\n    image.alt = alt;\n    if (isFunction(options.view)) {\n      addListener(element, EVENT_VIEW, options.view, {\n        once: true\n      });\n    }\n    if (dispatchEvent(element, EVENT_VIEW, {\n      originalImage: this.images[index],\n      index: index,\n      image: image\n    }) === false || !this.isShown || this.hiding || this.played) {\n      return this;\n    }\n    var activeItem = this.items[this.index];\n    if (activeItem) {\n      removeClass(activeItem, CLASS_ACTIVE);\n      activeItem.removeAttribute('aria-selected');\n    }\n    addClass(item, CLASS_ACTIVE);\n    item.setAttribute('aria-selected', true);\n    if (options.focus) {\n      item.focus();\n    }\n    this.image = image;\n    this.viewed = false;\n    this.index = index;\n    this.imageData = {};\n    addClass(image, CLASS_INVISIBLE);\n    if (options.loading) {\n      addClass(canvas, CLASS_LOADING);\n    }\n    canvas.innerHTML = '';\n    canvas.appendChild(image);\n\n    // Center current item\n    this.renderList();\n\n    // Clear title\n    title.innerHTML = '';\n\n    // Generate title after viewed\n    var onViewed = function onViewed() {\n      var imageData = _this2.imageData;\n      var render = Array.isArray(options.title) ? options.title[1] : options.title;\n      title.innerHTML = escapeHTMLEntities(isFunction(render) ? render.call(_this2, image, imageData) : \"\".concat(alt, \" (\").concat(imageData.naturalWidth, \" \\xD7 \").concat(imageData.naturalHeight, \")\"));\n    };\n    var onLoad;\n    var onError;\n    addListener(element, EVENT_VIEWED, onViewed, {\n      once: true\n    });\n    this.viewing = {\n      abort: function abort() {\n        removeListener(element, EVENT_VIEWED, onViewed);\n        if (image.complete) {\n          if (_this2.imageRendering) {\n            _this2.imageRendering.abort();\n          } else if (_this2.imageInitializing) {\n            _this2.imageInitializing.abort();\n          }\n        } else {\n          // Cancel download to save bandwidth.\n          image.src = '';\n          removeListener(image, EVENT_LOAD, onLoad);\n          if (_this2.timeout) {\n            clearTimeout(_this2.timeout);\n          }\n        }\n      }\n    };\n    if (image.complete) {\n      this.load();\n    } else {\n      addListener(image, EVENT_LOAD, onLoad = function onLoad() {\n        removeListener(image, EVENT_ERROR, onError);\n        _this2.load();\n      }, {\n        once: true\n      });\n      addListener(image, EVENT_ERROR, onError = function onError() {\n        removeListener(image, EVENT_LOAD, onLoad);\n        if (_this2.timeout) {\n          clearTimeout(_this2.timeout);\n          _this2.timeout = false;\n        }\n        removeClass(image, CLASS_INVISIBLE);\n        if (options.loading) {\n          removeClass(_this2.canvas, CLASS_LOADING);\n        }\n      }, {\n        once: true\n      });\n      if (this.timeout) {\n        clearTimeout(this.timeout);\n      }\n\n      // Make the image visible if it fails to load within 1s\n      this.timeout = setTimeout(function () {\n        removeClass(image, CLASS_INVISIBLE);\n        _this2.timeout = false;\n      }, 1000);\n    }\n    return this;\n  },\n  /**\n   * View the previous image\n   * @param {boolean} [loop=false] - Indicate if view the last one\n   * when it is the first one at present.\n   * @returns {Viewer} this\n   */\n  prev: function prev() {\n    var loop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var index = this.index - 1;\n    if (index < 0) {\n      index = loop ? this.length - 1 : 0;\n    }\n    this.view(index);\n    return this;\n  },\n  /**\n   * View the next image\n   * @param {boolean} [loop=false] - Indicate if view the first one\n   * when it is the last one at present.\n   * @returns {Viewer} this\n   */\n  next: function next() {\n    var loop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var maxIndex = this.length - 1;\n    var index = this.index + 1;\n    if (index > maxIndex) {\n      index = loop ? 0 : maxIndex;\n    }\n    this.view(index);\n    return this;\n  },\n  /**\n   * Move the image with relative offsets.\n   * @param {number} x - The moving distance in the horizontal direction.\n   * @param {number} [y=x] The moving distance in the vertical direction.\n   * @returns {Viewer} this\n   */\n  move: function move(x) {\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n    var imageData = this.imageData;\n    this.moveTo(isUndefined(x) ? x : imageData.x + Number(x), isUndefined(y) ? y : imageData.y + Number(y));\n    return this;\n  },\n  /**\n   * Move the image to an absolute point.\n   * @param {number} x - The new position in the horizontal direction.\n   * @param {number} [y=x] - The new position in the vertical direction.\n   * @param {Event} [_originalEvent=null] - The original event if any.\n   * @returns {Viewer} this\n   */\n  moveTo: function moveTo(x) {\n    var _this3 = this;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n    var _originalEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var element = this.element,\n      options = this.options,\n      imageData = this.imageData;\n    x = Number(x);\n    y = Number(y);\n    if (this.viewed && !this.played && options.movable) {\n      var oldX = imageData.x;\n      var oldY = imageData.y;\n      var changed = false;\n      if (isNumber(x)) {\n        changed = true;\n      } else {\n        x = oldX;\n      }\n      if (isNumber(y)) {\n        changed = true;\n      } else {\n        y = oldY;\n      }\n      if (changed) {\n        if (isFunction(options.move)) {\n          addListener(element, EVENT_MOVE, options.move, {\n            once: true\n          });\n        }\n        if (dispatchEvent(element, EVENT_MOVE, {\n          x: x,\n          y: y,\n          oldX: oldX,\n          oldY: oldY,\n          originalEvent: _originalEvent\n        }) === false) {\n          return this;\n        }\n        imageData.x = x;\n        imageData.y = y;\n        imageData.left = x;\n        imageData.top = y;\n        this.moving = true;\n        this.renderImage(function () {\n          _this3.moving = false;\n          if (isFunction(options.moved)) {\n            addListener(element, EVENT_MOVED, options.moved, {\n              once: true\n            });\n          }\n          dispatchEvent(element, EVENT_MOVED, {\n            x: x,\n            y: y,\n            oldX: oldX,\n            oldY: oldY,\n            originalEvent: _originalEvent\n          }, {\n            cancelable: false\n          });\n        });\n      }\n    }\n    return this;\n  },\n  /**\n   * Rotate the image with a relative degree.\n   * @param {number} degree - The rotate degree.\n   * @returns {Viewer} this\n   */\n  rotate: function rotate(degree) {\n    this.rotateTo((this.imageData.rotate || 0) + Number(degree));\n    return this;\n  },\n  /**\n   * Rotate the image to an absolute degree.\n   * @param {number} degree - The rotate degree.\n   * @returns {Viewer} this\n   */\n  rotateTo: function rotateTo(degree) {\n    var _this4 = this;\n    var element = this.element,\n      options = this.options,\n      imageData = this.imageData;\n    degree = Number(degree);\n    if (isNumber(degree) && this.viewed && !this.played && options.rotatable) {\n      var oldDegree = imageData.rotate;\n      if (isFunction(options.rotate)) {\n        addListener(element, EVENT_ROTATE, options.rotate, {\n          once: true\n        });\n      }\n      if (dispatchEvent(element, EVENT_ROTATE, {\n        degree: degree,\n        oldDegree: oldDegree\n      }) === false) {\n        return this;\n      }\n      imageData.rotate = degree;\n      this.rotating = true;\n      this.renderImage(function () {\n        _this4.rotating = false;\n        if (isFunction(options.rotated)) {\n          addListener(element, EVENT_ROTATED, options.rotated, {\n            once: true\n          });\n        }\n        dispatchEvent(element, EVENT_ROTATED, {\n          degree: degree,\n          oldDegree: oldDegree\n        }, {\n          cancelable: false\n        });\n      });\n    }\n    return this;\n  },\n  /**\n   * Scale the image on the x-axis.\n   * @param {number} scaleX - The scale ratio on the x-axis.\n   * @returns {Viewer} this\n   */\n  scaleX: function scaleX(_scaleX) {\n    this.scale(_scaleX, this.imageData.scaleY);\n    return this;\n  },\n  /**\n   * Scale the image on the y-axis.\n   * @param {number} scaleY - The scale ratio on the y-axis.\n   * @returns {Viewer} this\n   */\n  scaleY: function scaleY(_scaleY) {\n    this.scale(this.imageData.scaleX, _scaleY);\n    return this;\n  },\n  /**\n   * Scale the image.\n   * @param {number} scaleX - The scale ratio on the x-axis.\n   * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.\n   * @returns {Viewer} this\n   */\n  scale: function scale(scaleX) {\n    var _this5 = this;\n    var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;\n    var element = this.element,\n      options = this.options,\n      imageData = this.imageData;\n    scaleX = Number(scaleX);\n    scaleY = Number(scaleY);\n    if (this.viewed && !this.played && options.scalable) {\n      var oldScaleX = imageData.scaleX;\n      var oldScaleY = imageData.scaleY;\n      var changed = false;\n      if (isNumber(scaleX)) {\n        changed = true;\n      } else {\n        scaleX = oldScaleX;\n      }\n      if (isNumber(scaleY)) {\n        changed = true;\n      } else {\n        scaleY = oldScaleY;\n      }\n      if (changed) {\n        if (isFunction(options.scale)) {\n          addListener(element, EVENT_SCALE, options.scale, {\n            once: true\n          });\n        }\n        if (dispatchEvent(element, EVENT_SCALE, {\n          scaleX: scaleX,\n          scaleY: scaleY,\n          oldScaleX: oldScaleX,\n          oldScaleY: oldScaleY\n        }) === false) {\n          return this;\n        }\n        imageData.scaleX = scaleX;\n        imageData.scaleY = scaleY;\n        this.scaling = true;\n        this.renderImage(function () {\n          _this5.scaling = false;\n          if (isFunction(options.scaled)) {\n            addListener(element, EVENT_SCALED, options.scaled, {\n              once: true\n            });\n          }\n          dispatchEvent(element, EVENT_SCALED, {\n            scaleX: scaleX,\n            scaleY: scaleY,\n            oldScaleX: oldScaleX,\n            oldScaleY: oldScaleY\n          }, {\n            cancelable: false\n          });\n        });\n      }\n    }\n    return this;\n  },\n  /**\n   * Zoom the image with a relative ratio.\n   * @param {number} ratio - The target ratio.\n   * @param {boolean} [showTooltip=false] - Indicates whether to show the tooltip.\n   * @param {Object} [pivot] - The pivot point coordinate for zooming.\n   * @param {Event} [_originalEvent=null] - The original event if any.\n   * @returns {Viewer} this\n   */\n  zoom: function zoom(ratio) {\n    var showTooltip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var pivot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var _originalEvent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var imageData = this.imageData;\n    ratio = Number(ratio);\n    if (ratio < 0) {\n      ratio = 1 / (1 - ratio);\n    } else {\n      ratio = 1 + ratio;\n    }\n    this.zoomTo(imageData.width * ratio / imageData.naturalWidth, showTooltip, pivot, _originalEvent);\n    return this;\n  },\n  /**\n   * Zoom the image to an absolute ratio.\n   * @param {number} ratio - The target ratio.\n   * @param {boolean} [showTooltip] - Indicates whether to show the tooltip.\n   * @param {Object} [pivot] - The pivot point coordinate for zooming.\n   * @param {Event} [_originalEvent=null] - The original event if any.\n   * @param {Event} [_zoomable=false] - Indicates if the current zoom is available or not.\n   * @returns {Viewer} this\n   */\n  zoomTo: function zoomTo(ratio) {\n    var _this6 = this;\n    var showTooltip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var pivot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var _originalEvent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var _zoomable = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var element = this.element,\n      options = this.options,\n      pointers = this.pointers,\n      imageData = this.imageData;\n    var x = imageData.x,\n      y = imageData.y,\n      width = imageData.width,\n      height = imageData.height,\n      naturalWidth = imageData.naturalWidth,\n      naturalHeight = imageData.naturalHeight;\n    ratio = Math.max(0, ratio);\n    if (isNumber(ratio) && this.viewed && !this.played && (_zoomable || options.zoomable)) {\n      if (!_zoomable) {\n        var minZoomRatio = Math.max(0.01, options.minZoomRatio);\n        var maxZoomRatio = Math.min(100, options.maxZoomRatio);\n        ratio = Math.min(Math.max(ratio, minZoomRatio), maxZoomRatio);\n      }\n      if (_originalEvent) {\n        switch (_originalEvent.type) {\n          case 'wheel':\n            if (options.zoomRatio >= 0.055 && ratio > 0.95 && ratio < 1.05) {\n              ratio = 1;\n            }\n            break;\n          case 'pointermove':\n          case 'touchmove':\n          case 'mousemove':\n            if (ratio > 0.99 && ratio < 1.01) {\n              ratio = 1;\n            }\n            break;\n        }\n      }\n      var newWidth = naturalWidth * ratio;\n      var newHeight = naturalHeight * ratio;\n      var offsetWidth = newWidth - width;\n      var offsetHeight = newHeight - height;\n      var oldRatio = imageData.ratio;\n      if (isFunction(options.zoom)) {\n        addListener(element, EVENT_ZOOM, options.zoom, {\n          once: true\n        });\n      }\n      if (dispatchEvent(element, EVENT_ZOOM, {\n        ratio: ratio,\n        oldRatio: oldRatio,\n        originalEvent: _originalEvent\n      }) === false) {\n        return this;\n      }\n      this.zooming = true;\n      if (_originalEvent) {\n        var offset = getOffset(this.viewer);\n        var center = pointers && Object.keys(pointers).length > 0 ? getPointersCenter(pointers) : {\n          pageX: _originalEvent.pageX,\n          pageY: _originalEvent.pageY\n        };\n\n        // Zoom from the triggering point of the event\n        imageData.x -= offsetWidth * ((center.pageX - offset.left - x) / width);\n        imageData.y -= offsetHeight * ((center.pageY - offset.top - y) / height);\n      } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {\n        imageData.x -= offsetWidth * ((pivot.x - x) / width);\n        imageData.y -= offsetHeight * ((pivot.y - y) / height);\n      } else {\n        // Zoom from the center of the image\n        imageData.x -= offsetWidth / 2;\n        imageData.y -= offsetHeight / 2;\n      }\n      imageData.left = imageData.x;\n      imageData.top = imageData.y;\n      imageData.width = newWidth;\n      imageData.height = newHeight;\n      imageData.oldRatio = oldRatio;\n      imageData.ratio = ratio;\n      this.renderImage(function () {\n        _this6.zooming = false;\n        if (isFunction(options.zoomed)) {\n          addListener(element, EVENT_ZOOMED, options.zoomed, {\n            once: true\n          });\n        }\n        dispatchEvent(element, EVENT_ZOOMED, {\n          ratio: ratio,\n          oldRatio: oldRatio,\n          originalEvent: _originalEvent\n        }, {\n          cancelable: false\n        });\n      });\n      if (showTooltip) {\n        this.tooltip();\n      }\n    }\n    return this;\n  },\n  /**\n   * Play the images\n   * @param {boolean|FullscreenOptions} [fullscreen=false] - Indicate if request fullscreen or not.\n   * @returns {Viewer} this\n   */\n  play: function play() {\n    var _this7 = this;\n    var fullscreen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!this.isShown || this.played) {\n      return this;\n    }\n    var element = this.element,\n      options = this.options;\n    if (isFunction(options.play)) {\n      addListener(element, EVENT_PLAY, options.play, {\n        once: true\n      });\n    }\n    if (dispatchEvent(element, EVENT_PLAY) === false) {\n      return this;\n    }\n    var player = this.player;\n    var onLoad = this.loadImage.bind(this);\n    var list = [];\n    var total = 0;\n    var index = 0;\n    this.played = true;\n    this.onLoadWhenPlay = onLoad;\n    if (fullscreen) {\n      this.requestFullscreen(fullscreen);\n    }\n    addClass(player, CLASS_SHOW);\n    forEach(this.items, function (item, i) {\n      var img = item.querySelector('img');\n      var image = document.createElement('img');\n      image.src = getData(img, 'originalUrl');\n      image.alt = img.getAttribute('alt');\n      image.referrerPolicy = img.referrerPolicy;\n      total += 1;\n      addClass(image, CLASS_FADE);\n      toggleClass(image, CLASS_TRANSITION, options.transition);\n      if (hasClass(item, CLASS_ACTIVE)) {\n        addClass(image, CLASS_IN);\n        index = i;\n      }\n      list.push(image);\n      addListener(image, EVENT_LOAD, onLoad, {\n        once: true\n      });\n      player.appendChild(image);\n    });\n    if (isNumber(options.interval) && options.interval > 0) {\n      var prev = function prev() {\n        clearTimeout(_this7.playing.timeout);\n        removeClass(list[index], CLASS_IN);\n        index -= 1;\n        index = index >= 0 ? index : total - 1;\n        addClass(list[index], CLASS_IN);\n        _this7.playing.timeout = setTimeout(prev, options.interval);\n      };\n      var next = function next() {\n        clearTimeout(_this7.playing.timeout);\n        removeClass(list[index], CLASS_IN);\n        index += 1;\n        index = index < total ? index : 0;\n        addClass(list[index], CLASS_IN);\n        _this7.playing.timeout = setTimeout(next, options.interval);\n      };\n      if (total > 1) {\n        this.playing = {\n          prev: prev,\n          next: next,\n          timeout: setTimeout(next, options.interval)\n        };\n      }\n    }\n    return this;\n  },\n  // Stop play\n  stop: function stop() {\n    var _this8 = this;\n    if (!this.played) {\n      return this;\n    }\n    var element = this.element,\n      options = this.options;\n    if (isFunction(options.stop)) {\n      addListener(element, EVENT_STOP, options.stop, {\n        once: true\n      });\n    }\n    if (dispatchEvent(element, EVENT_STOP) === false) {\n      return this;\n    }\n    var player = this.player;\n    clearTimeout(this.playing.timeout);\n    this.playing = false;\n    this.played = false;\n    forEach(player.getElementsByTagName('img'), function (image) {\n      removeListener(image, EVENT_LOAD, _this8.onLoadWhenPlay);\n    });\n    removeClass(player, CLASS_SHOW);\n    player.innerHTML = '';\n    this.exitFullscreen();\n    return this;\n  },\n  // Enter modal mode (only available in inline mode)\n  full: function full() {\n    var _this9 = this;\n    var options = this.options,\n      viewer = this.viewer,\n      image = this.image,\n      list = this.list;\n    if (!this.isShown || this.played || this.fulled || !options.inline) {\n      return this;\n    }\n    this.fulled = true;\n    this.open();\n    addClass(this.button, CLASS_FULLSCREEN_EXIT);\n    if (options.transition) {\n      removeClass(list, CLASS_TRANSITION);\n      if (this.viewed) {\n        removeClass(image, CLASS_TRANSITION);\n      }\n    }\n    addClass(viewer, CLASS_FIXED);\n    viewer.setAttribute('role', 'dialog');\n    viewer.setAttribute('aria-labelledby', this.title.id);\n    viewer.setAttribute('aria-modal', true);\n    viewer.removeAttribute('style');\n    setStyle(viewer, {\n      zIndex: options.zIndex\n    });\n    if (options.focus) {\n      this.enforceFocus();\n    }\n    this.initContainer();\n    this.viewerData = assign({}, this.containerData);\n    this.renderList();\n    if (this.viewed) {\n      this.initImage(function () {\n        _this9.renderImage(function () {\n          if (options.transition) {\n            setTimeout(function () {\n              addClass(image, CLASS_TRANSITION);\n              addClass(list, CLASS_TRANSITION);\n            }, 0);\n          }\n        });\n      });\n    }\n    return this;\n  },\n  // Exit modal mode (only available in inline mode)\n  exit: function exit() {\n    var _this10 = this;\n    var options = this.options,\n      viewer = this.viewer,\n      image = this.image,\n      list = this.list;\n    if (!this.isShown || this.played || !this.fulled || !options.inline) {\n      return this;\n    }\n    this.fulled = false;\n    this.close();\n    removeClass(this.button, CLASS_FULLSCREEN_EXIT);\n    if (options.transition) {\n      removeClass(list, CLASS_TRANSITION);\n      if (this.viewed) {\n        removeClass(image, CLASS_TRANSITION);\n      }\n    }\n    if (options.focus) {\n      this.clearEnforceFocus();\n    }\n    viewer.removeAttribute('role');\n    viewer.removeAttribute('aria-labelledby');\n    viewer.removeAttribute('aria-modal');\n    removeClass(viewer, CLASS_FIXED);\n    setStyle(viewer, {\n      zIndex: options.zIndexInline\n    });\n    this.viewerData = assign({}, this.parentData);\n    this.renderViewer();\n    this.renderList();\n    if (this.viewed) {\n      this.initImage(function () {\n        _this10.renderImage(function () {\n          if (options.transition) {\n            setTimeout(function () {\n              addClass(image, CLASS_TRANSITION);\n              addClass(list, CLASS_TRANSITION);\n            }, 0);\n          }\n        });\n      });\n    }\n    return this;\n  },\n  // Show the current ratio of the image with percentage\n  tooltip: function tooltip() {\n    var _this11 = this;\n    var options = this.options,\n      tooltipBox = this.tooltipBox,\n      imageData = this.imageData;\n    if (!this.viewed || this.played || !options.tooltip) {\n      return this;\n    }\n    tooltipBox.textContent = \"\".concat(Math.round(imageData.ratio * 100), \"%\");\n    if (!this.tooltipping) {\n      if (options.transition) {\n        if (this.fading) {\n          dispatchEvent(tooltipBox, EVENT_TRANSITION_END);\n        }\n        addClass(tooltipBox, CLASS_SHOW);\n        addClass(tooltipBox, CLASS_FADE);\n        addClass(tooltipBox, CLASS_TRANSITION);\n        tooltipBox.removeAttribute('aria-hidden');\n\n        // Force reflow to enable CSS3 transition\n        tooltipBox.initialOffsetWidth = tooltipBox.offsetWidth;\n        addClass(tooltipBox, CLASS_IN);\n      } else {\n        addClass(tooltipBox, CLASS_SHOW);\n        tooltipBox.removeAttribute('aria-hidden');\n      }\n    } else {\n      clearTimeout(this.tooltipping);\n    }\n    this.tooltipping = setTimeout(function () {\n      if (options.transition) {\n        addListener(tooltipBox, EVENT_TRANSITION_END, function () {\n          removeClass(tooltipBox, CLASS_SHOW);\n          removeClass(tooltipBox, CLASS_FADE);\n          removeClass(tooltipBox, CLASS_TRANSITION);\n          tooltipBox.setAttribute('aria-hidden', true);\n          _this11.fading = false;\n        }, {\n          once: true\n        });\n        removeClass(tooltipBox, CLASS_IN);\n        _this11.fading = true;\n      } else {\n        removeClass(tooltipBox, CLASS_SHOW);\n        tooltipBox.setAttribute('aria-hidden', true);\n      }\n      _this11.tooltipping = false;\n    }, 1000);\n    return this;\n  },\n  /**\n   * Toggle the image size between its current size and natural size\n   * @param {Event} [_originalEvent=null] - The original event if any.\n   * @returns {Viewer} this\n   */\n  toggle: function toggle() {\n    var _originalEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (this.imageData.ratio === 1) {\n      this.zoomTo(this.imageData.oldRatio, true, null, _originalEvent);\n    } else {\n      this.zoomTo(1, true, null, _originalEvent);\n    }\n    return this;\n  },\n  // Reset the image to its initial state\n  reset: function reset() {\n    if (this.viewed && !this.played) {\n      this.imageData = assign({}, this.initialImageData);\n      this.renderImage();\n    }\n    return this;\n  },\n  // Update viewer when images changed\n  update: function update() {\n    var _this12 = this;\n    var element = this.element,\n      options = this.options,\n      isImg = this.isImg;\n\n    // Destroy viewer if the target image was deleted\n    if (isImg && !element.parentNode) {\n      return this.destroy();\n    }\n    var images = [];\n    forEach(isImg ? [element] : element.querySelectorAll('img'), function (image) {\n      if (isFunction(options.filter)) {\n        if (options.filter.call(_this12, image)) {\n          images.push(image);\n        }\n      } else if (_this12.getImageURL(image)) {\n        images.push(image);\n      }\n    });\n    if (!images.length) {\n      return this;\n    }\n    this.images = images;\n    this.length = images.length;\n    if (this.ready) {\n      var changedIndexes = [];\n      forEach(this.items, function (item, i) {\n        var img = item.querySelector('img');\n        var image = images[i];\n        if (image && img) {\n          if (image.src !== img.src\n\n          // Title changed (#408)\n          || image.alt !== img.alt) {\n            changedIndexes.push(i);\n          }\n        } else {\n          changedIndexes.push(i);\n        }\n      });\n      setStyle(this.list, {\n        width: 'auto'\n      });\n      this.initList();\n      if (this.isShown) {\n        if (this.length) {\n          if (this.viewed) {\n            var changedIndex = changedIndexes.indexOf(this.index);\n            if (changedIndex >= 0) {\n              this.viewed = false;\n              this.view(Math.max(Math.min(this.index - changedIndex, this.length - 1), 0));\n            } else {\n              var activeItem = this.items[this.index];\n\n              // Reactivate the current viewing item after reset the list.\n              addClass(activeItem, CLASS_ACTIVE);\n              activeItem.setAttribute('aria-selected', true);\n            }\n          }\n        } else {\n          this.image = null;\n          this.viewed = false;\n          this.index = 0;\n          this.imageData = {};\n          this.canvas.innerHTML = '';\n          this.title.innerHTML = '';\n        }\n      }\n    } else {\n      this.build();\n    }\n    return this;\n  },\n  // Destroy the viewer\n  destroy: function destroy() {\n    var element = this.element,\n      options = this.options;\n    if (!element[NAMESPACE]) {\n      return this;\n    }\n    this.destroyed = true;\n    if (this.ready) {\n      if (this.played) {\n        this.stop();\n      }\n      if (options.inline) {\n        if (this.fulled) {\n          this.exit();\n        }\n        this.unbind();\n      } else if (this.isShown) {\n        if (this.viewing) {\n          if (this.imageRendering) {\n            this.imageRendering.abort();\n          } else if (this.imageInitializing) {\n            this.imageInitializing.abort();\n          }\n        }\n        if (this.hiding) {\n          this.transitioning.abort();\n        }\n        this.hidden();\n      } else if (this.showing) {\n        this.transitioning.abort();\n        this.hidden();\n      }\n      this.ready = false;\n      this.viewer.parentNode.removeChild(this.viewer);\n    } else if (options.inline) {\n      if (this.delaying) {\n        this.delaying.abort();\n      } else if (this.initializing) {\n        this.initializing.abort();\n      }\n    }\n    if (!options.inline) {\n      removeListener(element, EVENT_CLICK, this.onStart);\n    }\n    element[NAMESPACE] = undefined;\n    return this;\n  }\n};\n\nvar others = {\n  getImageURL: function getImageURL(image) {\n    var url = this.options.url;\n    if (isString(url)) {\n      url = image.getAttribute(url);\n    } else if (isFunction(url)) {\n      url = url.call(this, image);\n    } else {\n      url = '';\n    }\n    return url;\n  },\n  enforceFocus: function enforceFocus() {\n    var _this = this;\n    this.clearEnforceFocus();\n    addListener(document, EVENT_FOCUSIN, this.onFocusin = function (event) {\n      var viewer = _this.viewer;\n      var target = event.target;\n      if (target === document || target === viewer || viewer.contains(target)) {\n        return;\n      }\n      while (target) {\n        // Avoid conflicts with other modals (#474, #540)\n        if (target.getAttribute('tabindex') !== null || target.getAttribute('aria-modal') === 'true') {\n          return;\n        }\n        target = target.parentElement;\n      }\n      viewer.focus();\n    });\n  },\n  clearEnforceFocus: function clearEnforceFocus() {\n    if (this.onFocusin) {\n      removeListener(document, EVENT_FOCUSIN, this.onFocusin);\n      this.onFocusin = null;\n    }\n  },\n  open: function open() {\n    var body = this.body;\n    addClass(body, CLASS_OPEN);\n    if (this.scrollbarWidth > 0) {\n      body.style.paddingRight = \"\".concat(this.scrollbarWidth + (parseFloat(this.initialBodyComputedPaddingRight) || 0), \"px\");\n    }\n  },\n  close: function close() {\n    var body = this.body;\n    removeClass(body, CLASS_OPEN);\n    if (this.scrollbarWidth > 0) {\n      body.style.paddingRight = this.initialBodyPaddingRight;\n    }\n  },\n  shown: function shown() {\n    var element = this.element,\n      options = this.options,\n      viewer = this.viewer;\n    this.fulled = true;\n    this.isShown = true;\n    this.render();\n    this.bind();\n    this.showing = false;\n    if (options.focus) {\n      viewer.focus();\n      this.enforceFocus();\n    }\n    if (isFunction(options.shown)) {\n      addListener(element, EVENT_SHOWN, options.shown, {\n        once: true\n      });\n    }\n    if (dispatchEvent(element, EVENT_SHOWN) === false) {\n      return;\n    }\n    if (this.ready && this.isShown && !this.hiding) {\n      this.view(this.index);\n    }\n  },\n  hidden: function hidden() {\n    var element = this.element,\n      options = this.options,\n      viewer = this.viewer;\n    if (options.fucus) {\n      this.clearEnforceFocus();\n    }\n    this.close();\n    this.unbind();\n    addClass(viewer, CLASS_HIDE);\n    viewer.removeAttribute('role');\n    viewer.removeAttribute('aria-labelledby');\n    viewer.removeAttribute('aria-modal');\n    viewer.setAttribute('aria-hidden', true);\n    this.resetList();\n    this.resetImage();\n    this.fulled = false;\n    this.viewed = false;\n    this.isShown = false;\n    this.hiding = false;\n    if (!this.destroyed) {\n      if (isFunction(options.hidden)) {\n        addListener(element, EVENT_HIDDEN, options.hidden, {\n          once: true\n        });\n      }\n      dispatchEvent(element, EVENT_HIDDEN, null, {\n        cancelable: false\n      });\n    }\n  },\n  requestFullscreen: function requestFullscreen(options) {\n    var document = this.element.ownerDocument;\n    if (this.fulled && !(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {\n      var documentElement = document.documentElement;\n\n      // Element.requestFullscreen()\n      if (documentElement.requestFullscreen) {\n        // Avoid TypeError when convert `options` to dictionary\n        if (isPlainObject(options)) {\n          documentElement.requestFullscreen(options);\n        } else {\n          documentElement.requestFullscreen();\n        }\n      } else if (documentElement.webkitRequestFullscreen) {\n        documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);\n      } else if (documentElement.mozRequestFullScreen) {\n        documentElement.mozRequestFullScreen();\n      } else if (documentElement.msRequestFullscreen) {\n        documentElement.msRequestFullscreen();\n      }\n    }\n  },\n  exitFullscreen: function exitFullscreen() {\n    var document = this.element.ownerDocument;\n    if (this.fulled && (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {\n      // Document.exitFullscreen()\n      if (document.exitFullscreen) {\n        document.exitFullscreen();\n      } else if (document.webkitExitFullscreen) {\n        document.webkitExitFullscreen();\n      } else if (document.mozCancelFullScreen) {\n        document.mozCancelFullScreen();\n      } else if (document.msExitFullscreen) {\n        document.msExitFullscreen();\n      }\n    }\n  },\n  change: function change(event) {\n    var options = this.options,\n      pointers = this.pointers;\n    var pointer = pointers[Object.keys(pointers)[0]];\n\n    // In the case of the `pointers` object is empty (#421)\n    if (!pointer) {\n      return;\n    }\n    var offsetX = pointer.endX - pointer.startX;\n    var offsetY = pointer.endY - pointer.startY;\n    switch (this.action) {\n      // Move the current image\n      case ACTION_MOVE:\n        if (offsetX !== 0 || offsetY !== 0) {\n          this.pointerMoved = true;\n          this.move(offsetX, offsetY, event);\n        }\n        break;\n\n      // Zoom the current image\n      case ACTION_ZOOM:\n        this.zoom(getMaxZoomRatio(pointers), false, null, event);\n        break;\n      case ACTION_SWITCH:\n        {\n          this.action = 'switched';\n          var absoluteOffsetX = Math.abs(offsetX);\n          if (absoluteOffsetX > 1 && absoluteOffsetX > Math.abs(offsetY)) {\n            // Empty `pointers` as `touchend` event will not be fired after swiped in iOS browsers.\n            this.pointers = {};\n            if (offsetX > 1) {\n              this.prev(options.loop);\n            } else if (offsetX < -1) {\n              this.next(options.loop);\n            }\n          }\n          break;\n        }\n    }\n\n    // Override\n    forEach(pointers, function (p) {\n      p.startX = p.endX;\n      p.startY = p.endY;\n    });\n  },\n  isSwitchable: function isSwitchable() {\n    var imageData = this.imageData,\n      viewerData = this.viewerData;\n    return this.length > 1 && imageData.x >= 0 && imageData.y >= 0 && imageData.width <= viewerData.width && imageData.height <= viewerData.height;\n  }\n};\n\nvar AnotherViewer = WINDOW.Viewer;\nvar getUniqueID = function (id) {\n  return function () {\n    id += 1;\n    return id;\n  };\n}(-1);\nvar Viewer = /*#__PURE__*/function () {\n  /**\n   * Create a new Viewer.\n   * @param {Element} element - The target element for viewing.\n   * @param {Object} [options={}] - The configuration options.\n   */\n  function Viewer(element) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Viewer);\n    if (!element || element.nodeType !== 1) {\n      throw new Error('The first argument is required and must be an element.');\n    }\n    this.element = element;\n    this.options = assign({}, DEFAULTS, isPlainObject(options) && options);\n    this.action = false;\n    this.fading = false;\n    this.fulled = false;\n    this.hiding = false;\n    this.imageClicked = false;\n    this.imageData = {};\n    this.index = this.options.initialViewIndex;\n    this.isImg = false;\n    this.isShown = false;\n    this.length = 0;\n    this.moving = false;\n    this.played = false;\n    this.playing = false;\n    this.pointers = {};\n    this.ready = false;\n    this.rotating = false;\n    this.scaling = false;\n    this.showing = false;\n    this.timeout = false;\n    this.tooltipping = false;\n    this.viewed = false;\n    this.viewing = false;\n    this.wheeling = false;\n    this.zooming = false;\n    this.pointerMoved = false;\n    this.id = getUniqueID();\n    this.init();\n  }\n  _createClass(Viewer, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n      var element = this.element,\n        options = this.options;\n      if (element[NAMESPACE]) {\n        return;\n      }\n      element[NAMESPACE] = this;\n\n      // The `focus` option requires the `keyboard` option set to `true`.\n      if (options.focus && !options.keyboard) {\n        options.focus = false;\n      }\n      var isImg = element.localName === 'img';\n      var images = [];\n      forEach(isImg ? [element] : element.querySelectorAll('img'), function (image) {\n        if (isFunction(options.filter)) {\n          if (options.filter.call(_this, image)) {\n            images.push(image);\n          }\n        } else if (_this.getImageURL(image)) {\n          images.push(image);\n        }\n      });\n      this.isImg = isImg;\n      this.length = images.length;\n      this.images = images;\n      this.initBody();\n\n      // Override `transition` option if it is not supported\n      if (isUndefined(document.createElement(NAMESPACE).style.transition)) {\n        options.transition = false;\n      }\n      if (options.inline) {\n        var count = 0;\n        var progress = function progress() {\n          count += 1;\n          if (count === _this.length) {\n            var timeout;\n            _this.initializing = false;\n            _this.delaying = {\n              abort: function abort() {\n                clearTimeout(timeout);\n              }\n            };\n\n            // build asynchronously to keep `this.viewer` is accessible in `ready` event handler.\n            timeout = setTimeout(function () {\n              _this.delaying = false;\n              _this.build();\n            }, 0);\n          }\n        };\n        this.initializing = {\n          abort: function abort() {\n            forEach(images, function (image) {\n              if (!image.complete) {\n                removeListener(image, EVENT_LOAD, progress);\n                removeListener(image, EVENT_ERROR, progress);\n              }\n            });\n          }\n        };\n        forEach(images, function (image) {\n          if (image.complete) {\n            progress();\n          } else {\n            var onLoad;\n            var onError;\n            addListener(image, EVENT_LOAD, onLoad = function onLoad() {\n              removeListener(image, EVENT_ERROR, onError);\n              progress();\n            }, {\n              once: true\n            });\n            addListener(image, EVENT_ERROR, onError = function onError() {\n              removeListener(image, EVENT_LOAD, onLoad);\n              progress();\n            }, {\n              once: true\n            });\n          }\n        });\n      } else {\n        addListener(element, EVENT_CLICK, this.onStart = function (_ref) {\n          var target = _ref.target;\n          if (target.localName === 'img' && (!isFunction(options.filter) || options.filter.call(_this, target))) {\n            _this.view(_this.images.indexOf(target));\n          }\n        });\n      }\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      if (this.ready) {\n        return;\n      }\n      var element = this.element,\n        options = this.options;\n      var parent = element.parentNode;\n      var template = document.createElement('div');\n      template.innerHTML = TEMPLATE;\n      var viewer = template.querySelector(\".\".concat(NAMESPACE, \"-container\"));\n      var title = viewer.querySelector(\".\".concat(NAMESPACE, \"-title\"));\n      var toolbar = viewer.querySelector(\".\".concat(NAMESPACE, \"-toolbar\"));\n      var navbar = viewer.querySelector(\".\".concat(NAMESPACE, \"-navbar\"));\n      var button = viewer.querySelector(\".\".concat(NAMESPACE, \"-button\"));\n      var canvas = viewer.querySelector(\".\".concat(NAMESPACE, \"-canvas\"));\n      this.parent = parent;\n      this.viewer = viewer;\n      this.title = title;\n      this.toolbar = toolbar;\n      this.navbar = navbar;\n      this.button = button;\n      this.canvas = canvas;\n      this.footer = viewer.querySelector(\".\".concat(NAMESPACE, \"-footer\"));\n      this.tooltipBox = viewer.querySelector(\".\".concat(NAMESPACE, \"-tooltip\"));\n      this.player = viewer.querySelector(\".\".concat(NAMESPACE, \"-player\"));\n      this.list = viewer.querySelector(\".\".concat(NAMESPACE, \"-list\"));\n      viewer.id = \"\".concat(NAMESPACE).concat(this.id);\n      title.id = \"\".concat(NAMESPACE, \"Title\").concat(this.id);\n      addClass(title, !options.title ? CLASS_HIDE : getResponsiveClass(Array.isArray(options.title) ? options.title[0] : options.title));\n      addClass(navbar, !options.navbar ? CLASS_HIDE : getResponsiveClass(options.navbar));\n      toggleClass(button, CLASS_HIDE, !options.button);\n      if (options.keyboard) {\n        button.setAttribute('tabindex', 0);\n      }\n      if (options.backdrop) {\n        addClass(viewer, \"\".concat(NAMESPACE, \"-backdrop\"));\n        if (!options.inline && options.backdrop !== 'static') {\n          setData(canvas, DATA_ACTION, 'hide');\n        }\n      }\n      if (isString(options.className) && options.className) {\n        // In case there are multiple class names\n        options.className.split(REGEXP_SPACES).forEach(function (className) {\n          addClass(viewer, className);\n        });\n      }\n      if (options.toolbar) {\n        var list = document.createElement('ul');\n        var custom = isPlainObject(options.toolbar);\n        var zoomButtons = BUTTONS.slice(0, 3);\n        var rotateButtons = BUTTONS.slice(7, 9);\n        var scaleButtons = BUTTONS.slice(9);\n        if (!custom) {\n          addClass(toolbar, getResponsiveClass(options.toolbar));\n        }\n        forEach(custom ? options.toolbar : BUTTONS, function (value, index) {\n          var deep = custom && isPlainObject(value);\n          var name = custom ? hyphenate(index) : value;\n          var show = deep && !isUndefined(value.show) ? value.show : value;\n          if (!show || !options.zoomable && zoomButtons.indexOf(name) !== -1 || !options.rotatable && rotateButtons.indexOf(name) !== -1 || !options.scalable && scaleButtons.indexOf(name) !== -1) {\n            return;\n          }\n          var size = deep && !isUndefined(value.size) ? value.size : value;\n          var click = deep && !isUndefined(value.click) ? value.click : value;\n          var item = document.createElement('li');\n          if (options.keyboard) {\n            item.setAttribute('tabindex', 0);\n          }\n          item.setAttribute('role', 'button');\n          addClass(item, \"\".concat(NAMESPACE, \"-\").concat(name));\n          if (!isFunction(click)) {\n            setData(item, DATA_ACTION, name);\n          }\n          if (isNumber(show)) {\n            addClass(item, getResponsiveClass(show));\n          }\n          if (['small', 'large'].indexOf(size) !== -1) {\n            addClass(item, \"\".concat(NAMESPACE, \"-\").concat(size));\n          } else if (name === 'play') {\n            addClass(item, \"\".concat(NAMESPACE, \"-large\"));\n          }\n          if (isFunction(click)) {\n            addListener(item, EVENT_CLICK, click);\n          }\n          list.appendChild(item);\n        });\n        toolbar.appendChild(list);\n      } else {\n        addClass(toolbar, CLASS_HIDE);\n      }\n      if (!options.rotatable) {\n        var rotates = toolbar.querySelectorAll('li[class*=\"rotate\"]');\n        addClass(rotates, CLASS_INVISIBLE);\n        forEach(rotates, function (rotate) {\n          toolbar.appendChild(rotate);\n        });\n      }\n      if (options.inline) {\n        addClass(button, CLASS_FULLSCREEN);\n        setStyle(viewer, {\n          zIndex: options.zIndexInline\n        });\n        if (window.getComputedStyle(parent).position === 'static') {\n          setStyle(parent, {\n            position: 'relative'\n          });\n        }\n        parent.insertBefore(viewer, element.nextSibling);\n      } else {\n        addClass(button, CLASS_CLOSE);\n        addClass(viewer, CLASS_FIXED);\n        addClass(viewer, CLASS_FADE);\n        addClass(viewer, CLASS_HIDE);\n        setStyle(viewer, {\n          zIndex: options.zIndex\n        });\n        var container = options.container;\n        if (isString(container)) {\n          container = element.ownerDocument.querySelector(container);\n        }\n        if (!container) {\n          container = this.body;\n        }\n        container.appendChild(viewer);\n      }\n      if (options.inline) {\n        this.render();\n        this.bind();\n        this.isShown = true;\n      }\n      this.ready = true;\n      if (isFunction(options.ready)) {\n        addListener(element, EVENT_READY, options.ready, {\n          once: true\n        });\n      }\n      if (dispatchEvent(element, EVENT_READY) === false) {\n        this.ready = false;\n        return;\n      }\n      if (this.ready && options.inline) {\n        this.view(this.index);\n      }\n    }\n\n    /**\n     * Get the no conflict viewer class.\n     * @returns {Viewer} The viewer class.\n     */\n  }], [{\n    key: \"noConflict\",\n    value: function noConflict() {\n      window.Viewer = AnotherViewer;\n      return Viewer;\n    }\n\n    /**\n     * Change the default options.\n     * @param {Object} options - The new default options.\n     */\n  }, {\n    key: \"setDefaults\",\n    value: function setDefaults(options) {\n      assign(DEFAULTS, isPlainObject(options) && options);\n    }\n  }]);\n  return Viewer;\n}();\nassign(Viewer.prototype, render, events, handlers, methods, others);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlld2VyanMvZGlzdC92aWV3ZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdB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QUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVEsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEOztBQUU2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2dhbGxlcnktYXBwLy4vbm9kZV9tb2R1bGVzL3ZpZXdlcmpzL2Rpc3Qvdmlld2VyLmVzbS5qcz8zZjY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVmlld2VyLmpzIHYxLjExLjZcbiAqIGh0dHBzOi8vZmVuZ3l1YW5jaGVuLmdpdGh1Yi5pby92aWV3ZXJqc1xuICpcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQgQ2hlbiBGZW5neXVhblxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMy0wOS0xN1QwMzoxNjozOC4wNTJaXG4gKi9cblxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG4gIHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTtcbiAgICB9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcbiAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG4gICAgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbnZhciBERUZBVUxUUyA9IHtcbiAgLyoqXG4gICAqIEVuYWJsZSBhIG1vZGFsIGJhY2tkcm9wLCBzcGVjaWZ5IGBzdGF0aWNgIGZvciBhIGJhY2tkcm9wXG4gICAqIHdoaWNoIGRvZXNuJ3QgY2xvc2UgdGhlIG1vZGFsIG9uIGNsaWNrLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGJhY2tkcm9wOiB0cnVlLFxuICAvKipcbiAgICogU2hvdyB0aGUgYnV0dG9uIG9uIHRoZSB0b3AtcmlnaHQgb2YgdGhlIHZpZXdlci5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBidXR0b246IHRydWUsXG4gIC8qKlxuICAgKiBTaG93IHRoZSBuYXZiYXIuXG4gICAqIEB0eXBlIHtib29sZWFuIHwgbnVtYmVyfVxuICAgKi9cbiAgbmF2YmFyOiB0cnVlLFxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgdmlzaWJpbGl0eSBhbmQgdGhlIGNvbnRlbnQgb2YgdGhlIHRpdGxlLlxuICAgKiBAdHlwZSB7Ym9vbGVhbiB8IG51bWJlciB8IEZ1bmN0aW9uIHwgQXJyYXl9XG4gICAqL1xuICB0aXRsZTogdHJ1ZSxcbiAgLyoqXG4gICAqIFNob3cgdGhlIHRvb2xiYXIuXG4gICAqIEB0eXBlIHtib29sZWFuIHwgbnVtYmVyIHwgT2JqZWN0fVxuICAgKi9cbiAgdG9vbGJhcjogdHJ1ZSxcbiAgLyoqXG4gICAqIEN1c3RvbSBjbGFzcyBuYW1lKHMpIHRvIGFkZCB0byB0aGUgdmlld2VyJ3Mgcm9vdCBlbGVtZW50LlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgY2xhc3NOYW1lOiAnJyxcbiAgLyoqXG4gICAqIERlZmluZSB3aGVyZSB0byBwdXQgdGhlIHZpZXdlciBpbiBtb2RhbCBtb2RlLlxuICAgKiBAdHlwZSB7c3RyaW5nIHwgRWxlbWVudH1cbiAgICovXG4gIGNvbnRhaW5lcjogJ2JvZHknLFxuICAvKipcbiAgICogRmlsdGVyIHRoZSBpbWFnZXMgZm9yIHZpZXdpbmcuIFJldHVybiB0cnVlIGlmIHRoZSBpbWFnZSBpcyB2aWV3YWJsZS5cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgZmlsdGVyOiBudWxsLFxuICAvKipcbiAgICogRW5hYmxlIHRvIHJlcXVlc3QgZnVsbHNjcmVlbiB3aGVuIHBsYXkuXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRnVsbHNjcmVlbk9wdGlvbnN9XG4gICAqIEB0eXBlIHtib29sZWFufEZ1bGxzY3JlZW5PcHRpb25zfVxuICAgKi9cbiAgZnVsbHNjcmVlbjogdHJ1ZSxcbiAgLyoqXG4gICAqIERlZmluZSB0aGUgZXh0cmEgYXR0cmlidXRlcyB0byBpbmhlcml0IGZyb20gdGhlIG9yaWdpbmFsIGltYWdlLlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICBpbmhlcml0ZWRBdHRyaWJ1dGVzOiBbJ2Nyb3NzT3JpZ2luJywgJ2RlY29kaW5nJywgJ2lzTWFwJywgJ2xvYWRpbmcnLCAncmVmZXJyZXJQb2xpY3knLCAnc2l6ZXMnLCAnc3Jjc2V0JywgJ3VzZU1hcCddLFxuICAvKipcbiAgICogRGVmaW5lIHRoZSBpbml0aWFsIGNvdmVyYWdlIG9mIHRoZSB2aWV3aW5nIGltYWdlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgaW5pdGlhbENvdmVyYWdlOiAwLjksXG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIGluaXRpYWwgaW5kZXggb2YgdGhlIGltYWdlIGZvciB2aWV3aW5nLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgaW5pdGlhbFZpZXdJbmRleDogMCxcbiAgLyoqXG4gICAqIEVuYWJsZSBpbmxpbmUgbW9kZS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBpbmxpbmU6IGZhbHNlLFxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IGJldHdlZW4gYXV0b21hdGljYWxseSBjeWNsaW5nIGFuIGltYWdlIHdoZW4gcGxheWluZy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGludGVydmFsOiA1MDAwLFxuICAvKipcbiAgICogRW5hYmxlIGtleWJvYXJkIHN1cHBvcnQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAga2V5Ym9hcmQ6IHRydWUsXG4gIC8qKlxuICAgKiBGb2N1cyB0aGUgdmlld2VyIHdoZW4gaW5pdGlhbGl6ZWQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZm9jdXM6IHRydWUsXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSBpZiBzaG93IGEgbG9hZGluZyBzcGlubmVyIHdoZW4gbG9hZCBpbWFnZSBvciBub3QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgbG9hZGluZzogdHJ1ZSxcbiAgLyoqXG4gICAqIEluZGljYXRlIGlmIGVuYWJsZSBsb29wIHZpZXdpbmcgb3Igbm90LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGxvb3A6IHRydWUsXG4gIC8qKlxuICAgKiBNaW4gd2lkdGggb2YgdGhlIHZpZXdlciBpbiBpbmxpbmUgbW9kZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIG1pbldpZHRoOiAyMDAsXG4gIC8qKlxuICAgKiBNaW4gaGVpZ2h0IG9mIHRoZSB2aWV3ZXIgaW4gaW5saW5lIG1vZGUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBtaW5IZWlnaHQ6IDEwMCxcbiAgLyoqXG4gICAqIEVuYWJsZSB0byBtb3ZlIHRoZSBpbWFnZS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBtb3ZhYmxlOiB0cnVlLFxuICAvKipcbiAgICogRW5hYmxlIHRvIHJvdGF0ZSB0aGUgaW1hZ2UuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgcm90YXRhYmxlOiB0cnVlLFxuICAvKipcbiAgICogRW5hYmxlIHRvIHNjYWxlIHRoZSBpbWFnZS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzY2FsYWJsZTogdHJ1ZSxcbiAgLyoqXG4gICAqIEVuYWJsZSB0byB6b29tIHRoZSBpbWFnZS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB6b29tYWJsZTogdHJ1ZSxcbiAgLyoqXG4gICAqIEVuYWJsZSB0byB6b29tIHRoZSBjdXJyZW50IGltYWdlIGJ5IGRyYWdnaW5nIG9uIHRoZSB0b3VjaCBzY3JlZW4uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgem9vbU9uVG91Y2g6IHRydWUsXG4gIC8qKlxuICAgKiBFbmFibGUgdG8gem9vbSB0aGUgaW1hZ2UgYnkgd2hlZWxpbmcgbW91c2UuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgem9vbU9uV2hlZWw6IHRydWUsXG4gIC8qKlxuICAgKiBFbmFibGUgdG8gc2xpZGUgdG8gdGhlIG5leHQgb3IgcHJldmlvdXMgaW1hZ2UgYnkgc3dpcGluZyBvbiB0aGUgdG91Y2ggc2NyZWVuLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHNsaWRlT25Ub3VjaDogdHJ1ZSxcbiAgLyoqXG4gICAqIEluZGljYXRlIGlmIHRvZ2dsZSB0aGUgaW1hZ2Ugc2l6ZSBiZXR3ZWVuIGl0cyBuYXR1cmFsIHNpemVcbiAgICogYW5kIGluaXRpYWwgc2l6ZSB3aGVuIGRvdWJsZSBjbGljayBvbiB0aGUgaW1hZ2Ugb3Igbm90LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRvZ2dsZU9uRGJsY2xpY2s6IHRydWUsXG4gIC8qKlxuICAgKiBTaG93IHRoZSB0b29sdGlwIHdpdGggaW1hZ2UgcmF0aW8gKHBlcmNlbnRhZ2UpIHdoZW4gem9vbSBpbiBvciB6b29tIG91dC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0b29sdGlwOiB0cnVlLFxuICAvKipcbiAgICogRW5hYmxlIENTUzMgVHJhbnNpdGlvbiBmb3Igc29tZSBzcGVjaWFsIGVsZW1lbnRzLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRyYW5zaXRpb246IHRydWUsXG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIENTUyBgei1pbmRleGAgdmFsdWUgb2Ygdmlld2VyIGluIG1vZGFsIG1vZGUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB6SW5kZXg6IDIwMTUsXG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIENTUyBgei1pbmRleGAgdmFsdWUgb2Ygdmlld2VyIGluIGlubGluZSBtb2RlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgekluZGV4SW5saW5lOiAwLFxuICAvKipcbiAgICogRGVmaW5lIHRoZSByYXRpbyB3aGVuIHpvb20gdGhlIGltYWdlIGJ5IHdoZWVsaW5nIG1vdXNlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgem9vbVJhdGlvOiAwLjEsXG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIG1pbiByYXRpbyBvZiB0aGUgaW1hZ2Ugd2hlbiB6b29tIG91dC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIG1pblpvb21SYXRpbzogMC4wMSxcbiAgLyoqXG4gICAqIERlZmluZSB0aGUgbWF4IHJhdGlvIG9mIHRoZSBpbWFnZSB3aGVuIHpvb20gaW4uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBtYXhab29tUmF0aW86IDEwMCxcbiAgLyoqXG4gICAqIERlZmluZSB3aGVyZSB0byBnZXQgdGhlIG9yaWdpbmFsIGltYWdlIFVSTCBmb3Igdmlld2luZy5cbiAgICogQHR5cGUge3N0cmluZyB8IEZ1bmN0aW9ufVxuICAgKi9cbiAgdXJsOiAnc3JjJyxcbiAgLyoqXG4gICAqIEV2ZW50IHNob3J0Y3V0cy5cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgcmVhZHk6IG51bGwsXG4gIHNob3c6IG51bGwsXG4gIHNob3duOiBudWxsLFxuICBoaWRlOiBudWxsLFxuICBoaWRkZW46IG51bGwsXG4gIHZpZXc6IG51bGwsXG4gIHZpZXdlZDogbnVsbCxcbiAgbW92ZTogbnVsbCxcbiAgbW92ZWQ6IG51bGwsXG4gIHJvdGF0ZTogbnVsbCxcbiAgcm90YXRlZDogbnVsbCxcbiAgc2NhbGU6IG51bGwsXG4gIHNjYWxlZDogbnVsbCxcbiAgem9vbTogbnVsbCxcbiAgem9vbWVkOiBudWxsLFxuICBwbGF5OiBudWxsLFxuICBzdG9wOiBudWxsXG59O1xuXG52YXIgVEVNUExBVEUgPSAnPGRpdiBjbGFzcz1cInZpZXdlci1jb250YWluZXJcIiB0YWJpbmRleD1cIi0xXCIgdG91Y2gtYWN0aW9uPVwibm9uZVwiPicgKyAnPGRpdiBjbGFzcz1cInZpZXdlci1jYW52YXNcIj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJ2aWV3ZXItZm9vdGVyXCI+JyArICc8ZGl2IGNsYXNzPVwidmlld2VyLXRpdGxlXCI+PC9kaXY+JyArICc8ZGl2IGNsYXNzPVwidmlld2VyLXRvb2xiYXJcIj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJ2aWV3ZXItbmF2YmFyXCI+JyArICc8dWwgY2xhc3M9XCJ2aWV3ZXItbGlzdFwiIHJvbGU9XCJuYXZpZ2F0aW9uXCI+PC91bD4nICsgJzwvZGl2PicgKyAnPC9kaXY+JyArICc8ZGl2IGNsYXNzPVwidmlld2VyLXRvb2x0aXBcIiByb2xlPVwiYWxlcnRcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJ2aWV3ZXItYnV0dG9uXCIgZGF0YS12aWV3ZXItYWN0aW9uPVwibWl4XCIgcm9sZT1cImJ1dHRvblwiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cInZpZXdlci1wbGF5ZXJcIj48L2Rpdj4nICsgJzwvZGl2Pic7XG5cbnZhciBJU19CUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgV0lORE9XID0gSVNfQlJPV1NFUiA/IHdpbmRvdyA6IHt9O1xudmFyIElTX1RPVUNIX0RFVklDRSA9IElTX0JST1dTRVIgJiYgV0lORE9XLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICdvbnRvdWNoc3RhcnQnIGluIFdJTkRPVy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBmYWxzZTtcbnZhciBIQVNfUE9JTlRFUl9FVkVOVCA9IElTX0JST1dTRVIgPyAnUG9pbnRlckV2ZW50JyBpbiBXSU5ET1cgOiBmYWxzZTtcbnZhciBOQU1FU1BBQ0UgPSAndmlld2VyJztcblxuLy8gQWN0aW9uc1xudmFyIEFDVElPTl9NT1ZFID0gJ21vdmUnO1xudmFyIEFDVElPTl9TV0lUQ0ggPSAnc3dpdGNoJztcbnZhciBBQ1RJT05fWk9PTSA9ICd6b29tJztcblxuLy8gQ2xhc3Nlc1xudmFyIENMQVNTX0FDVElWRSA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItYWN0aXZlXCIpO1xudmFyIENMQVNTX0NMT1NFID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1jbG9zZVwiKTtcbnZhciBDTEFTU19GQURFID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1mYWRlXCIpO1xudmFyIENMQVNTX0ZJWEVEID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1maXhlZFwiKTtcbnZhciBDTEFTU19GVUxMU0NSRUVOID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1mdWxsc2NyZWVuXCIpO1xudmFyIENMQVNTX0ZVTExTQ1JFRU5fRVhJVCA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItZnVsbHNjcmVlbi1leGl0XCIpO1xudmFyIENMQVNTX0hJREUgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWhpZGVcIik7XG52YXIgQ0xBU1NfSElERV9NRF9ET1dOID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1oaWRlLW1kLWRvd25cIik7XG52YXIgQ0xBU1NfSElERV9TTV9ET1dOID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1oaWRlLXNtLWRvd25cIik7XG52YXIgQ0xBU1NfSElERV9YU19ET1dOID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1oaWRlLXhzLWRvd25cIik7XG52YXIgQ0xBU1NfSU4gPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWluXCIpO1xudmFyIENMQVNTX0lOVklTSUJMRSA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItaW52aXNpYmxlXCIpO1xudmFyIENMQVNTX0xPQURJTkcgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWxvYWRpbmdcIik7XG52YXIgQ0xBU1NfTU9WRSA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItbW92ZVwiKTtcbnZhciBDTEFTU19PUEVOID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1vcGVuXCIpO1xudmFyIENMQVNTX1NIT1cgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLXNob3dcIik7XG52YXIgQ0xBU1NfVFJBTlNJVElPTiA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItdHJhbnNpdGlvblwiKTtcblxuLy8gTmF0aXZlIGV2ZW50c1xudmFyIEVWRU5UX0NMSUNLID0gJ2NsaWNrJztcbnZhciBFVkVOVF9EQkxDTElDSyA9ICdkYmxjbGljayc7XG52YXIgRVZFTlRfRFJBR19TVEFSVCA9ICdkcmFnc3RhcnQnO1xudmFyIEVWRU5UX0ZPQ1VTSU4gPSAnZm9jdXNpbic7XG52YXIgRVZFTlRfS0VZX0RPV04gPSAna2V5ZG93bic7XG52YXIgRVZFTlRfTE9BRCA9ICdsb2FkJztcbnZhciBFVkVOVF9FUlJPUiA9ICdlcnJvcic7XG52YXIgRVZFTlRfVE9VQ0hfRU5EID0gSVNfVE9VQ0hfREVWSUNFID8gJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJyA6ICdtb3VzZXVwJztcbnZhciBFVkVOVF9UT1VDSF9NT1ZFID0gSVNfVE9VQ0hfREVWSUNFID8gJ3RvdWNobW92ZScgOiAnbW91c2Vtb3ZlJztcbnZhciBFVkVOVF9UT1VDSF9TVEFSVCA9IElTX1RPVUNIX0RFVklDRSA/ICd0b3VjaHN0YXJ0JyA6ICdtb3VzZWRvd24nO1xudmFyIEVWRU5UX1BPSU5URVJfRE9XTiA9IEhBU19QT0lOVEVSX0VWRU5UID8gJ3BvaW50ZXJkb3duJyA6IEVWRU5UX1RPVUNIX1NUQVJUO1xudmFyIEVWRU5UX1BPSU5URVJfTU9WRSA9IEhBU19QT0lOVEVSX0VWRU5UID8gJ3BvaW50ZXJtb3ZlJyA6IEVWRU5UX1RPVUNIX01PVkU7XG52YXIgRVZFTlRfUE9JTlRFUl9VUCA9IEhBU19QT0lOVEVSX0VWRU5UID8gJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJyA6IEVWRU5UX1RPVUNIX0VORDtcbnZhciBFVkVOVF9SRVNJWkUgPSAncmVzaXplJztcbnZhciBFVkVOVF9UUkFOU0lUSU9OX0VORCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBFVkVOVF9XSEVFTCA9ICd3aGVlbCc7XG5cbi8vIEN1c3RvbSBldmVudHNcbnZhciBFVkVOVF9SRUFEWSA9ICdyZWFkeSc7XG52YXIgRVZFTlRfU0hPVyA9ICdzaG93JztcbnZhciBFVkVOVF9TSE9XTiA9ICdzaG93bic7XG52YXIgRVZFTlRfSElERSA9ICdoaWRlJztcbnZhciBFVkVOVF9ISURERU4gPSAnaGlkZGVuJztcbnZhciBFVkVOVF9WSUVXID0gJ3ZpZXcnO1xudmFyIEVWRU5UX1ZJRVdFRCA9ICd2aWV3ZWQnO1xudmFyIEVWRU5UX01PVkUgPSAnbW92ZSc7XG52YXIgRVZFTlRfTU9WRUQgPSAnbW92ZWQnO1xudmFyIEVWRU5UX1JPVEFURSA9ICdyb3RhdGUnO1xudmFyIEVWRU5UX1JPVEFURUQgPSAncm90YXRlZCc7XG52YXIgRVZFTlRfU0NBTEUgPSAnc2NhbGUnO1xudmFyIEVWRU5UX1NDQUxFRCA9ICdzY2FsZWQnO1xudmFyIEVWRU5UX1pPT00gPSAnem9vbSc7XG52YXIgRVZFTlRfWk9PTUVEID0gJ3pvb21lZCc7XG52YXIgRVZFTlRfUExBWSA9ICdwbGF5JztcbnZhciBFVkVOVF9TVE9QID0gJ3N0b3AnO1xuXG4vLyBEYXRhIGtleXNcbnZhciBEQVRBX0FDVElPTiA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCJBY3Rpb25cIik7XG5cbi8vIFJlZ0V4cHNcbnZhciBSRUdFWFBfU1BBQ0VTID0gL1xcc1xccyovO1xuXG4vLyBNaXNjXG52YXIgQlVUVE9OUyA9IFsnem9vbS1pbicsICd6b29tLW91dCcsICdvbmUtdG8tb25lJywgJ3Jlc2V0JywgJ3ByZXYnLCAncGxheScsICduZXh0JywgJ3JvdGF0ZS1sZWZ0JywgJ3JvdGF0ZS1yaWdodCcsICdmbGlwLWhvcml6b250YWwnLCAnZmxpcC12ZXJ0aWNhbCddO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXG4gKi9cbnZhciBpc05hTiA9IE51bWJlci5pc05hTiB8fCBXSU5ET1cuaXNOYU47XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdW5kZWZpbmVkLlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdW5kZWZpbmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIF90eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG90eXBlID0gX2NvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gX2NvbnN0cnVjdG9yICYmIHByb3RvdHlwZSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvdHlwZSwgJ2lzUHJvdG90eXBlT2YnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgdGhlIGdpdmVuIGRhdGEuXG4gKiBAcGFyYW0geyp9IGRhdGEgLSBUaGUgZGF0YSB0byBpdGVyYXRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgcHJvY2VzcyBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50LlxuICogQHJldHVybnMgeyp9IFRoZSBvcmlnaW5hbCBkYXRhLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGlmIChkYXRhICYmIGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNOdW1iZXIoZGF0YS5sZW5ndGgpIC8qIGFycmF5LWxpa2UgKi8pIHtcbiAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGRhdGEsIGRhdGFbaV0sIGksIGRhdGEpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwoZGF0YSwgZGF0YVtrZXldLCBrZXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEV4dGVuZCB0aGUgZ2l2ZW4gb2JqZWN0LlxuICogQHBhcmFtIHsqfSBvYmogLSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkLlxuICogQHBhcmFtIHsqfSBhcmdzIC0gVGhlIHJlc3Qgb2JqZWN0cyB3aGljaCB3aWxsIGJlIG1lcmdlZCB0byB0aGUgZmlyc3Qgb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gVGhlIGV4dGVuZGVkIG9iamVjdC5cbiAqL1xudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gYXNzaWduKG9iaikge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9iaikgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIGlmIChpc09iamVjdChhcmcpKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGFyZykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBhcmdba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG52YXIgUkVHRVhQX1NVRkZJWCA9IC9eKD86d2lkdGh8aGVpZ2h0fGxlZnR8dG9wfG1hcmdpbkxlZnR8bWFyZ2luVG9wKSQvO1xuXG4vKipcbiAqIEFwcGx5IHN0eWxlcyB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXMgLSBUaGUgc3R5bGVzIGZvciBhcHBseWluZy5cbiAqL1xuZnVuY3Rpb24gc2V0U3R5bGUoZWxlbWVudCwgc3R5bGVzKSB7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gIGZvckVhY2goc3R5bGVzLCBmdW5jdGlvbiAodmFsdWUsIHByb3BlcnR5KSB7XG4gICAgaWYgKFJFR0VYUF9TVUZGSVgudGVzdChwcm9wZXJ0eSkgJiYgaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICB2YWx1ZSArPSAncHgnO1xuICAgIH1cbiAgICBzdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogRXNjYXBlIGEgc3RyaW5nIGZvciB1c2luZyBpbiBIVE1MLlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlSFRNTEVudGl0aWVzKHZhbHVlKSB7XG4gIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZS5yZXBsYWNlKC8mKD8hYW1wO3xxdW90O3wjMzk7fGx0O3xndDspL2csICcmYW1wOycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC8nL2csICcmIzM5OycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBoYXMgYSBzcGVjaWFsIGNsYXNzLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gY2hlY2suXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgY2xhc3MgdG8gc2VhcmNoLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWFsIGNsYXNzIHdhcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgdmFsdWUpIHtcbiAgaWYgKCFlbGVtZW50IHx8ICF2YWx1ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QgPyBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh2YWx1ZSkgOiBlbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKHZhbHVlKSA+IC0xO1xufVxuXG4vKipcbiAqIEFkZCBjbGFzc2VzIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIGNsYXNzZXMgdG8gYmUgYWRkZWQuXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIHZhbHVlKSB7XG4gIGlmICghZWxlbWVudCB8fCAhdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzTnVtYmVyKGVsZW1lbnQubGVuZ3RoKSkge1xuICAgIGZvckVhY2goZWxlbWVudCwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIGFkZENsYXNzKGVsZW0sIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnRyaW0oKTtcbiAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKGNsYXNzTmFtZS5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFwiXCIuY29uY2F0KGNsYXNzTmFtZSwgXCIgXCIpLmNvbmNhdCh2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3NlcyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIGNsYXNzZXMgdG8gYmUgcmVtb3ZlZC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgdmFsdWUpIHtcbiAgaWYgKCFlbGVtZW50IHx8ICF2YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNOdW1iZXIoZWxlbWVudC5sZW5ndGgpKSB7XG4gICAgZm9yRWFjaChlbGVtZW50LCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgcmVtb3ZlQ2xhc3MoZWxlbSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodmFsdWUpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZih2YWx1ZSkgPj0gMCkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZSh2YWx1ZSwgJycpO1xuICB9XG59XG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBjbGFzc2VzIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgY2xhc3NlcyB0byBiZSB0b2dnbGVkLlxuICogQHBhcmFtIHtib29sZWFufSBhZGRlZCAtIEFkZCBvbmx5LlxuICovXG5mdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCB2YWx1ZSwgYWRkZWQpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNOdW1iZXIoZWxlbWVudC5sZW5ndGgpKSB7XG4gICAgZm9yRWFjaChlbGVtZW50LCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgdG9nZ2xlQ2xhc3MoZWxlbSwgdmFsdWUsIGFkZGVkKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJRTEwLTExIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiBgY2xhc3NMaXN0LnRvZ2dsZWBcbiAgaWYgKGFkZGVkKSB7XG4gICAgYWRkQ2xhc3MoZWxlbWVudCwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIHZhbHVlKTtcbiAgfVxufVxudmFyIFJFR0VYUF9IWVBIRU5BVEUgPSAvKFthLXpcXGRdKShbQS1aXSkvZztcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGdpdmVuIHN0cmluZyBmcm9tIGNhbWVsQ2FzZSB0byBrZWJhYi1jYXNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHRyYW5zZm9ybWVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoUkVHRVhQX0hZUEhFTkFURSwgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBHZXQgZGF0YSBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgZGF0YSBrZXkgdG8gZ2V0LlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGRhdGEgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldERhdGEoZWxlbWVudCwgbmFtZSkge1xuICBpZiAoaXNPYmplY3QoZWxlbWVudFtuYW1lXSkpIHtcbiAgICByZXR1cm4gZWxlbWVudFtuYW1lXTtcbiAgfVxuICBpZiAoZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGF0YXNldFtuYW1lXTtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLVwiLmNvbmNhdChoeXBoZW5hdGUobmFtZSkpKTtcbn1cblxuLyoqXG4gKiBTZXQgZGF0YSB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRhdGEga2V5IHRvIHNldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gVGhlIGRhdGEgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNldERhdGEoZWxlbWVudCwgbmFtZSwgZGF0YSkge1xuICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICBlbGVtZW50W25hbWVdID0gZGF0YTtcbiAgfSBlbHNlIGlmIChlbGVtZW50LmRhdGFzZXQpIHtcbiAgICBlbGVtZW50LmRhdGFzZXRbbmFtZV0gPSBkYXRhO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1cIi5jb25jYXQoaHlwaGVuYXRlKG5hbWUpKSwgZGF0YSk7XG4gIH1cbn1cbnZhciBvbmNlU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3VwcG9ydGVkID0gZmFsc2U7XG4gIGlmIChJU19CUk9XU0VSKSB7XG4gICAgdmFyIG9uY2UgPSBmYWxzZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHt9O1xuICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnb25jZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gb25jZTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgc2V0dGVyIGNhbiBmaXggYSBgVHlwZUVycm9yYCBpbiBzdHJpY3QgbW9kZVxuICAgICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Vycm9ycy9HZXR0ZXJfb25seX1cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0XG4gICAgICAgKi9cbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIG9uY2UgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBXSU5ET1cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICBXSU5ET1cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydGVkO1xufSgpO1xuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lciBmcm9tIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlKHMpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgZXZlbnQgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBldmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIHZhciBoYW5kbGVyID0gbGlzdGVuZXI7XG4gIHR5cGUudHJpbSgpLnNwbGl0KFJFR0VYUF9TUEFDRVMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCFvbmNlU3VwcG9ydGVkKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gZWxlbWVudC5saXN0ZW5lcnM7XG4gICAgICBpZiAobGlzdGVuZXJzICYmIGxpc3RlbmVyc1tldmVudF0gJiYgbGlzdGVuZXJzW2V2ZW50XVtsaXN0ZW5lcl0pIHtcbiAgICAgICAgaGFuZGxlciA9IGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2V2ZW50XVtsaXN0ZW5lcl07XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhsaXN0ZW5lcnNbZXZlbnRdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobGlzdGVuZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgZWxlbWVudC5saXN0ZW5lcnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQWRkIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlKHMpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgZXZlbnQgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBldmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIHZhciBfaGFuZGxlciA9IGxpc3RlbmVyO1xuICB0eXBlLnRyaW0oKS5zcGxpdChSRUdFWFBfU1BBQ0VTKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChvcHRpb25zLm9uY2UgJiYgIW9uY2VTdXBwb3J0ZWQpIHtcbiAgICAgIHZhciBfZWxlbWVudCRsaXN0ZW5lcnMgPSBlbGVtZW50Lmxpc3RlbmVycyxcbiAgICAgICAgbGlzdGVuZXJzID0gX2VsZW1lbnQkbGlzdGVuZXJzID09PSB2b2lkIDAgPyB7fSA6IF9lbGVtZW50JGxpc3RlbmVycztcbiAgICAgIF9oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIF9oYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVyLmFwcGx5KGVsZW1lbnQsIGFyZ3MpO1xuICAgICAgfTtcbiAgICAgIGlmICghbGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdID0ge307XG4gICAgICB9XG4gICAgICBpZiAobGlzdGVuZXJzW2V2ZW50XVtsaXN0ZW5lcl0pIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXSA9IF9oYW5kbGVyO1xuICAgICAgZWxlbWVudC5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgfVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgX2hhbmRsZXIsIG9wdGlvbnMpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBldmVudCBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZXZlbnQgdHlwZShzKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGFkZGl0aW9uYWwgZXZlbnQgZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGFkZGl0aW9uYWwgZXZlbnQgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBJbmRpY2F0ZSBpZiB0aGUgZXZlbnQgaXMgZGVmYXVsdCBwcmV2ZW50ZWQgb3Igbm90LlxuICovXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIHR5cGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGV2ZW50O1xuXG4gIC8vIEV2ZW50IGFuZCBDdXN0b21FdmVudCBvbiBJRTktMTEgYXJlIGdsb2JhbCBvYmplY3RzLCBub3QgY29uc3RydWN0b3JzXG4gIGlmIChpc0Z1bmN0aW9uKEV2ZW50KSAmJiBpc0Z1bmN0aW9uKEN1c3RvbUV2ZW50KSkge1xuICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KHR5cGUsIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgZGV0YWlsOiBkYXRhXG4gICAgfSwgb3B0aW9ucykpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIHRydWUsIHRydWUsIGRhdGEpO1xuICB9XG4gIHJldHVybiBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb2Zmc2V0IGJhc2Ugb24gdGhlIGRvY3VtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxuICogQHJldHVybnMge09iamVjdH0gVGhlIG9mZnNldCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXQoZWxlbWVudCkge1xuICB2YXIgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBib3gubGVmdCArICh3aW5kb3cucGFnZVhPZmZzZXQgLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50TGVmdCksXG4gICAgdG9wOiBib3gudG9wICsgKHdpbmRvdy5wYWdlWU9mZnNldCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRUb3ApXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRyYW5zZm9ybXMgYmFzZSBvbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSB0YXJnZXQgb2JqZWN0LlxuICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgY29udGFpbnMgdHJhbnNmb3JtIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtcyhfcmVmKSB7XG4gIHZhciByb3RhdGUgPSBfcmVmLnJvdGF0ZSxcbiAgICBzY2FsZVggPSBfcmVmLnNjYWxlWCxcbiAgICBzY2FsZVkgPSBfcmVmLnNjYWxlWSxcbiAgICB0cmFuc2xhdGVYID0gX3JlZi50cmFuc2xhdGVYLFxuICAgIHRyYW5zbGF0ZVkgPSBfcmVmLnRyYW5zbGF0ZVk7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgaWYgKGlzTnVtYmVyKHRyYW5zbGF0ZVgpICYmIHRyYW5zbGF0ZVggIT09IDApIHtcbiAgICB2YWx1ZXMucHVzaChcInRyYW5zbGF0ZVgoXCIuY29uY2F0KHRyYW5zbGF0ZVgsIFwicHgpXCIpKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodHJhbnNsYXRlWSkgJiYgdHJhbnNsYXRlWSAhPT0gMCkge1xuICAgIHZhbHVlcy5wdXNoKFwidHJhbnNsYXRlWShcIi5jb25jYXQodHJhbnNsYXRlWSwgXCJweClcIikpO1xuICB9XG5cbiAgLy8gUm90YXRlIHNob3VsZCBjb21lIGZpcnN0IGJlZm9yZSBzY2FsZSB0byBtYXRjaCBvcmllbnRhdGlvbiB0cmFuc2Zvcm1cbiAgaWYgKGlzTnVtYmVyKHJvdGF0ZSkgJiYgcm90YXRlICE9PSAwKSB7XG4gICAgdmFsdWVzLnB1c2goXCJyb3RhdGUoXCIuY29uY2F0KHJvdGF0ZSwgXCJkZWcpXCIpKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIoc2NhbGVYKSAmJiBzY2FsZVggIT09IDEpIHtcbiAgICB2YWx1ZXMucHVzaChcInNjYWxlWChcIi5jb25jYXQoc2NhbGVYLCBcIilcIikpO1xuICB9XG4gIGlmIChpc051bWJlcihzY2FsZVkpICYmIHNjYWxlWSAhPT0gMSkge1xuICAgIHZhbHVlcy5wdXNoKFwic2NhbGVZKFwiLmNvbmNhdChzY2FsZVksIFwiKVwiKSk7XG4gIH1cbiAgdmFyIHRyYW5zZm9ybSA9IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXMuam9pbignICcpIDogJ25vbmUnO1xuICByZXR1cm4ge1xuICAgIFdlYmtpdFRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgIG1zVHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1cbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgYW4gaW1hZ2UgbmFtZSBmcm9tIGFuIGltYWdlIHVybC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdGFyZ2V0IHVybC5cbiAqIEBleGFtcGxlXG4gKiAvLyBwaWN0dXJlLmpwZ1xuICogZ2V0SW1hZ2VOYW1lRnJvbVVSTCgnaHR0cHM6Ly9kb21haW4uY29tL3BhdGgvdG8vcGljdHVyZS5qcGc/c2l6ZT0xMjgww5c5NjAnKVxuICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgY29udGFpbnMgdGhlIGltYWdlIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGdldEltYWdlTmFtZUZyb21VUkwodXJsKSB7XG4gIHJldHVybiBpc1N0cmluZyh1cmwpID8gZGVjb2RlVVJJQ29tcG9uZW50KHVybC5yZXBsYWNlKC9eLipcXC8vLCAnJykucmVwbGFjZSgvWz8mI10uKiQvLCAnJykpIDogJyc7XG59XG52YXIgSVNfU0FGQVJJID0gV0lORE9XLm5hdmlnYXRvciAmJiAvVmVyc2lvblxcL1xcZCsoXFwuXFxkKykrP1xccytTYWZhcmkvaS50ZXN0KFdJTkRPVy5uYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBHZXQgYW4gaW1hZ2UncyBuYXR1cmFsIHNpemVzLlxuICogQHBhcmFtIHtzdHJpbmd9IGltYWdlIC0gVGhlIHRhcmdldCBpbWFnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHZpZXdlciBvcHRpb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7SFRNTEltYWdlRWxlbWVudH0gVGhlIG5ldyBpbWFnZS5cbiAqL1xuZnVuY3Rpb24gZ2V0SW1hZ2VOYXR1cmFsU2l6ZXMoaW1hZ2UsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBuZXdJbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuXG4gIC8vIE1vZGVybiBicm93c2VycyAoZXhjZXB0IFNhZmFyaSlcbiAgaWYgKGltYWdlLm5hdHVyYWxXaWR0aCAmJiAhSVNfU0FGQVJJKSB7XG4gICAgY2FsbGJhY2soaW1hZ2UubmF0dXJhbFdpZHRoLCBpbWFnZS5uYXR1cmFsSGVpZ2h0KTtcbiAgICByZXR1cm4gbmV3SW1hZ2U7XG4gIH1cbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgbmV3SW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKG5ld0ltYWdlLndpZHRoLCBuZXdJbWFnZS5oZWlnaHQpO1xuICAgIGlmICghSVNfU0FGQVJJKSB7XG4gICAgICBib2R5LnJlbW92ZUNoaWxkKG5ld0ltYWdlKTtcbiAgICB9XG4gIH07XG4gIGZvckVhY2gob3B0aW9ucy5pbmhlcml0ZWRBdHRyaWJ1dGVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWx1ZSA9IGltYWdlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIG5ld0ltYWdlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgbmV3SW1hZ2Uuc3JjID0gaW1hZ2Uuc3JjO1xuXG4gIC8vIGlPUyBTYWZhcmkgd2lsbCBjb252ZXJ0IHRoZSBpbWFnZSBhdXRvbWF0aWNhbGx5XG4gIC8vIHdpdGggaXRzIG9yaWVudGF0aW9uIG9uY2UgYXBwZW5kIGl0IGludG8gRE9NXG4gIGlmICghSVNfU0FGQVJJKSB7XG4gICAgbmV3SW1hZ2Uuc3R5bGUuY3NzVGV4dCA9ICdsZWZ0OjA7JyArICdtYXgtaGVpZ2h0Om5vbmUhaW1wb3J0YW50OycgKyAnbWF4LXdpZHRoOm5vbmUhaW1wb3J0YW50OycgKyAnbWluLWhlaWdodDowIWltcG9ydGFudDsnICsgJ21pbi13aWR0aDowIWltcG9ydGFudDsnICsgJ29wYWNpdHk6MDsnICsgJ3Bvc2l0aW9uOmFic29sdXRlOycgKyAndG9wOjA7JyArICd6LWluZGV4Oi0xOyc7XG4gICAgYm9keS5hcHBlbmRDaGlsZChuZXdJbWFnZSk7XG4gIH1cbiAgcmV0dXJuIG5ld0ltYWdlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmVsYXRlZCBjbGFzcyBuYW1lIG9mIGEgcmVzcG9uc2l2ZSB0eXBlIG51bWJlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHJlc3BvbnNpdmUgdHlwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByZWxhdGVkIGNsYXNzIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGdldFJlc3BvbnNpdmVDbGFzcyh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBDTEFTU19ISURFX1hTX0RPV047XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIENMQVNTX0hJREVfU01fRE9XTjtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gQ0xBU1NfSElERV9NRF9ET1dOO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIG1heCByYXRpbyBvZiBhIGdyb3VwIG9mIHBvaW50ZXJzLlxuICogQHBhcmFtIHtzdHJpbmd9IHBvaW50ZXJzIC0gVGhlIHRhcmdldCBwb2ludGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByZXN1bHQgcmF0aW8uXG4gKi9cbmZ1bmN0aW9uIGdldE1heFpvb21SYXRpbyhwb2ludGVycykge1xuICB2YXIgcG9pbnRlcnMyID0gX29iamVjdFNwcmVhZDIoe30sIHBvaW50ZXJzKTtcbiAgdmFyIHJhdGlvcyA9IFtdO1xuICBmb3JFYWNoKHBvaW50ZXJzLCBmdW5jdGlvbiAocG9pbnRlciwgcG9pbnRlcklkKSB7XG4gICAgZGVsZXRlIHBvaW50ZXJzMltwb2ludGVySWRdO1xuICAgIGZvckVhY2gocG9pbnRlcnMyLCBmdW5jdGlvbiAocG9pbnRlcjIpIHtcbiAgICAgIHZhciB4MSA9IE1hdGguYWJzKHBvaW50ZXIuc3RhcnRYIC0gcG9pbnRlcjIuc3RhcnRYKTtcbiAgICAgIHZhciB5MSA9IE1hdGguYWJzKHBvaW50ZXIuc3RhcnRZIC0gcG9pbnRlcjIuc3RhcnRZKTtcbiAgICAgIHZhciB4MiA9IE1hdGguYWJzKHBvaW50ZXIuZW5kWCAtIHBvaW50ZXIyLmVuZFgpO1xuICAgICAgdmFyIHkyID0gTWF0aC5hYnMocG9pbnRlci5lbmRZIC0gcG9pbnRlcjIuZW5kWSk7XG4gICAgICB2YXIgejEgPSBNYXRoLnNxcnQoeDEgKiB4MSArIHkxICogeTEpO1xuICAgICAgdmFyIHoyID0gTWF0aC5zcXJ0KHgyICogeDIgKyB5MiAqIHkyKTtcbiAgICAgIHZhciByYXRpbyA9ICh6MiAtIHoxKSAvIHoxO1xuICAgICAgcmF0aW9zLnB1c2gocmF0aW8pO1xuICAgIH0pO1xuICB9KTtcbiAgcmF0aW9zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYSkgPCBNYXRoLmFicyhiKTtcbiAgfSk7XG4gIHJldHVybiByYXRpb3NbMF07XG59XG5cbi8qKlxuICogR2V0IGEgcG9pbnRlciBmcm9tIGFuIGV2ZW50IG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSB0YXJnZXQgZXZlbnQgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBlbmRPbmx5IC0gSW5kaWNhdGVzIGlmIG9ubHkgcmV0dXJucyB0aGUgZW5kIHBvaW50IGNvb3JkaW5hdGUgb3Igbm90LlxuICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdCBwb2ludGVyIGNvbnRhaW5zIHN0YXJ0IGFuZC9vciBlbmQgcG9pbnQgY29vcmRpbmF0ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFBvaW50ZXIoX3JlZjIsIGVuZE9ubHkpIHtcbiAgdmFyIHBhZ2VYID0gX3JlZjIucGFnZVgsXG4gICAgcGFnZVkgPSBfcmVmMi5wYWdlWTtcbiAgdmFyIGVuZCA9IHtcbiAgICBlbmRYOiBwYWdlWCxcbiAgICBlbmRZOiBwYWdlWVxuICB9O1xuICByZXR1cm4gZW5kT25seSA/IGVuZCA6IF9vYmplY3RTcHJlYWQyKHtcbiAgICB0aW1lU3RhbXA6IERhdGUubm93KCksXG4gICAgc3RhcnRYOiBwYWdlWCxcbiAgICBzdGFydFk6IHBhZ2VZXG4gIH0sIGVuZCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjZW50ZXIgcG9pbnQgY29vcmRpbmF0ZSBvZiBhIGdyb3VwIG9mIHBvaW50ZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJzIC0gVGhlIHRhcmdldCBwb2ludGVycy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjZW50ZXIgcG9pbnQgY29vcmRpbmF0ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRlcnNDZW50ZXIocG9pbnRlcnMpIHtcbiAgdmFyIHBhZ2VYID0gMDtcbiAgdmFyIHBhZ2VZID0gMDtcbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yRWFjaChwb2ludGVycywgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgdmFyIHN0YXJ0WCA9IF9yZWYzLnN0YXJ0WCxcbiAgICAgIHN0YXJ0WSA9IF9yZWYzLnN0YXJ0WTtcbiAgICBwYWdlWCArPSBzdGFydFg7XG4gICAgcGFnZVkgKz0gc3RhcnRZO1xuICAgIGNvdW50ICs9IDE7XG4gIH0pO1xuICBwYWdlWCAvPSBjb3VudDtcbiAgcGFnZVkgLz0gY291bnQ7XG4gIHJldHVybiB7XG4gICAgcGFnZVg6IHBhZ2VYLFxuICAgIHBhZ2VZOiBwYWdlWVxuICB9O1xufVxuXG52YXIgcmVuZGVyID0ge1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB0aGlzLmluaXRDb250YWluZXIoKTtcbiAgICB0aGlzLmluaXRWaWV3ZXIoKTtcbiAgICB0aGlzLmluaXRMaXN0KCk7XG4gICAgdGhpcy5yZW5kZXJWaWV3ZXIoKTtcbiAgfSxcbiAgaW5pdEJvZHk6IGZ1bmN0aW9uIGluaXRCb2R5KCkge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgdmFyIGJvZHkgPSBvd25lckRvY3VtZW50LmJvZHkgfHwgb3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnNjcm9sbGJhcldpZHRoID0gd2luZG93LmlubmVyV2lkdGggLSBvd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICB0aGlzLmluaXRpYWxCb2R5UGFkZGluZ1JpZ2h0ID0gYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQ7XG4gICAgdGhpcy5pbml0aWFsQm9keUNvbXB1dGVkUGFkZGluZ1JpZ2h0ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoYm9keSkucGFkZGluZ1JpZ2h0O1xuICB9LFxuICBpbml0Q29udGFpbmVyOiBmdW5jdGlvbiBpbml0Q29udGFpbmVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyRGF0YSA9IHtcbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgfTtcbiAgfSxcbiAgaW5pdFZpZXdlcjogZnVuY3Rpb24gaW5pdFZpZXdlcigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgIHZhciB2aWV3ZXJEYXRhO1xuICAgIGlmIChvcHRpb25zLmlubGluZSkge1xuICAgICAgdmlld2VyRGF0YSA9IHtcbiAgICAgICAgd2lkdGg6IE1hdGgubWF4KHBhcmVudC5vZmZzZXRXaWR0aCwgb3B0aW9ucy5taW5XaWR0aCksXG4gICAgICAgIGhlaWdodDogTWF0aC5tYXgocGFyZW50Lm9mZnNldEhlaWdodCwgb3B0aW9ucy5taW5IZWlnaHQpXG4gICAgICB9O1xuICAgICAgdGhpcy5wYXJlbnREYXRhID0gdmlld2VyRGF0YTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnVsbGVkIHx8ICF2aWV3ZXJEYXRhKSB7XG4gICAgICB2aWV3ZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhO1xuICAgIH1cbiAgICB0aGlzLnZpZXdlckRhdGEgPSBhc3NpZ24oe30sIHZpZXdlckRhdGEpO1xuICB9LFxuICByZW5kZXJWaWV3ZXI6IGZ1bmN0aW9uIHJlbmRlclZpZXdlcigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmlubGluZSAmJiAhdGhpcy5mdWxsZWQpIHtcbiAgICAgIHNldFN0eWxlKHRoaXMudmlld2VyLCB0aGlzLnZpZXdlckRhdGEpO1xuICAgIH1cbiAgfSxcbiAgaW5pdExpc3Q6IGZ1bmN0aW9uIGluaXRMaXN0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgbGlzdCA9IHRoaXMubGlzdDtcbiAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgIC8vIGluaXRMaXN0IG1heSBiZSBjYWxsZWQgaW4gdGhpcy51cGRhdGUsIHNvIHNob3VsZCBrZWVwIGlkZW1wb3RlbnRcbiAgICBsaXN0LmlubmVySFRNTCA9ICcnO1xuICAgIGZvckVhY2godGhpcy5pbWFnZXMsIGZ1bmN0aW9uIChpbWFnZSwgaW5kZXgpIHtcbiAgICAgIHZhciBzcmMgPSBpbWFnZS5zcmM7XG4gICAgICB2YXIgYWx0ID0gaW1hZ2UuYWx0IHx8IGdldEltYWdlTmFtZUZyb21VUkwoc3JjKTtcbiAgICAgIHZhciB1cmwgPSBfdGhpcy5nZXRJbWFnZVVSTChpbWFnZSk7XG4gICAgICBpZiAoc3JjIHx8IHVybCkge1xuICAgICAgICB2YXIgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgZm9yRWFjaChvcHRpb25zLmluaGVyaXRlZEF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gaW1hZ2UuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMubmF2YmFyKSB7XG4gICAgICAgICAgaW1nLnNyYyA9IHNyYyB8fCB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgaW1nLmFsdCA9IGFsdDtcbiAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC11cmwnLCB1cmwgfHwgc3JjKTtcbiAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLCBpbmRleCk7XG4gICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdkYXRhLXZpZXdlci1hY3Rpb24nLCAndmlldycpO1xuICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcbiAgICAgICAgaWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcbiAgICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtLmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgIGxpc3QuYXBwZW5kQ2hpbGQoaXRlbSk7XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgIGZvckVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgaW1hZ2UgPSBpdGVtLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgdmFyIG9uTG9hZDtcbiAgICAgIHZhciBvbkVycm9yO1xuICAgICAgc2V0RGF0YShpbWFnZSwgJ2ZpbGxlZCcsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMubG9hZGluZykge1xuICAgICAgICBhZGRDbGFzcyhpdGVtLCBDTEFTU19MT0FESU5HKTtcbiAgICAgIH1cbiAgICAgIGFkZExpc3RlbmVyKGltYWdlLCBFVkVOVF9MT0FELCBvbkxvYWQgPSBmdW5jdGlvbiBvbkxvYWQoZXZlbnQpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0VSUk9SLCBvbkVycm9yKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubG9hZGluZykge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGl0ZW0sIENMQVNTX0xPQURJTkcpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmxvYWRJbWFnZShldmVudCk7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgYWRkTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0VSUk9SLCBvbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcigpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0xPQUQsIG9uTG9hZCk7XG4gICAgICAgIGlmIChvcHRpb25zLmxvYWRpbmcpIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyhpdGVtLCBDTEFTU19MT0FESU5HKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uKSB7XG4gICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9WSUVXRUQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkQ2xhc3MobGlzdCwgQ0xBU1NfVFJBTlNJVElPTik7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyTGlzdDogZnVuY3Rpb24gcmVuZGVyTGlzdCgpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgIHZhciBpdGVtID0gdGhpcy5pdGVtc1tpbmRleF07XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXh0ID0gaXRlbS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgdmFyIGd1dHRlciA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5leHQgfHwgaXRlbSkubWFyZ2luTGVmdCwgMTApO1xuICAgIHZhciBvZmZzZXRXaWR0aCA9IGl0ZW0ub2Zmc2V0V2lkdGg7XG4gICAgdmFyIG91dGVyV2lkdGggPSBvZmZzZXRXaWR0aCArIGd1dHRlcjtcblxuICAgIC8vIFBsYWNlIHRoZSBhY3RpdmUgaXRlbSBpbiB0aGUgY2VudGVyIG9mIHRoZSBzY3JlZW5cbiAgICBzZXRTdHlsZSh0aGlzLmxpc3QsIGFzc2lnbih7XG4gICAgICB3aWR0aDogb3V0ZXJXaWR0aCAqIHRoaXMubGVuZ3RoIC0gZ3V0dGVyXG4gICAgfSwgZ2V0VHJhbnNmb3Jtcyh7XG4gICAgICB0cmFuc2xhdGVYOiAodGhpcy52aWV3ZXJEYXRhLndpZHRoIC0gb2Zmc2V0V2lkdGgpIC8gMiAtIG91dGVyV2lkdGggKiBpbmRleFxuICAgIH0pKSk7XG4gIH0sXG4gIHJlc2V0TGlzdDogZnVuY3Rpb24gcmVzZXRMaXN0KCkge1xuICAgIHZhciBsaXN0ID0gdGhpcy5saXN0O1xuICAgIGxpc3QuaW5uZXJIVE1MID0gJyc7XG4gICAgcmVtb3ZlQ2xhc3MobGlzdCwgQ0xBU1NfVFJBTlNJVElPTik7XG4gICAgc2V0U3R5bGUobGlzdCwgZ2V0VHJhbnNmb3Jtcyh7XG4gICAgICB0cmFuc2xhdGVYOiAwXG4gICAgfSkpO1xuICB9LFxuICBpbml0SW1hZ2U6IGZ1bmN0aW9uIGluaXRJbWFnZShkb25lKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBpbWFnZSA9IHRoaXMuaW1hZ2UsXG4gICAgICB2aWV3ZXJEYXRhID0gdGhpcy52aWV3ZXJEYXRhO1xuICAgIHZhciBmb290ZXJIZWlnaHQgPSB0aGlzLmZvb3Rlci5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIHZpZXdlcldpZHRoID0gdmlld2VyRGF0YS53aWR0aDtcbiAgICB2YXIgdmlld2VySGVpZ2h0ID0gTWF0aC5tYXgodmlld2VyRGF0YS5oZWlnaHQgLSBmb290ZXJIZWlnaHQsIGZvb3RlckhlaWdodCk7XG4gICAgdmFyIG9sZEltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhIHx8IHt9O1xuICAgIHZhciBzaXppbmdJbWFnZTtcbiAgICB0aGlzLmltYWdlSW5pdGlhbGl6aW5nID0ge1xuICAgICAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICBzaXppbmdJbWFnZS5vbmxvYWQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgc2l6aW5nSW1hZ2UgPSBnZXRJbWFnZU5hdHVyYWxTaXplcyhpbWFnZSwgb3B0aW9ucywgZnVuY3Rpb24gKG5hdHVyYWxXaWR0aCwgbmF0dXJhbEhlaWdodCkge1xuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gbmF0dXJhbFdpZHRoIC8gbmF0dXJhbEhlaWdodDtcbiAgICAgIHZhciBpbml0aWFsQ292ZXJhZ2UgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBvcHRpb25zLmluaXRpYWxDb3ZlcmFnZSkpO1xuICAgICAgdmFyIHdpZHRoID0gdmlld2VyV2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdmlld2VySGVpZ2h0O1xuICAgICAgX3RoaXMyLmltYWdlSW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICBpZiAodmlld2VySGVpZ2h0ICogYXNwZWN0UmF0aW8gPiB2aWV3ZXJXaWR0aCkge1xuICAgICAgICBoZWlnaHQgPSB2aWV3ZXJXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSB2aWV3ZXJIZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgIH1cbiAgICAgIGluaXRpYWxDb3ZlcmFnZSA9IGlzTnVtYmVyKGluaXRpYWxDb3ZlcmFnZSkgPyBpbml0aWFsQ292ZXJhZ2UgOiAwLjk7XG4gICAgICB3aWR0aCA9IE1hdGgubWluKHdpZHRoICogaW5pdGlhbENvdmVyYWdlLCBuYXR1cmFsV2lkdGgpO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0ICogaW5pdGlhbENvdmVyYWdlLCBuYXR1cmFsSGVpZ2h0KTtcbiAgICAgIHZhciBsZWZ0ID0gKHZpZXdlcldpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgIHZhciB0b3AgPSAodmlld2VySGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0ge1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgeDogbGVmdCxcbiAgICAgICAgeTogdG9wLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBvbGRSYXRpbzogMSxcbiAgICAgICAgcmF0aW86IHdpZHRoIC8gbmF0dXJhbFdpZHRoLFxuICAgICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgICAgIG5hdHVyYWxXaWR0aDogbmF0dXJhbFdpZHRoLFxuICAgICAgICBuYXR1cmFsSGVpZ2h0OiBuYXR1cmFsSGVpZ2h0XG4gICAgICB9O1xuICAgICAgdmFyIGluaXRpYWxJbWFnZURhdGEgPSBhc3NpZ24oe30sIGltYWdlRGF0YSk7XG4gICAgICBpZiAob3B0aW9ucy5yb3RhdGFibGUpIHtcbiAgICAgICAgaW1hZ2VEYXRhLnJvdGF0ZSA9IG9sZEltYWdlRGF0YS5yb3RhdGUgfHwgMDtcbiAgICAgICAgaW5pdGlhbEltYWdlRGF0YS5yb3RhdGUgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2NhbGFibGUpIHtcbiAgICAgICAgaW1hZ2VEYXRhLnNjYWxlWCA9IG9sZEltYWdlRGF0YS5zY2FsZVggfHwgMTtcbiAgICAgICAgaW1hZ2VEYXRhLnNjYWxlWSA9IG9sZEltYWdlRGF0YS5zY2FsZVkgfHwgMTtcbiAgICAgICAgaW5pdGlhbEltYWdlRGF0YS5zY2FsZVggPSAxO1xuICAgICAgICBpbml0aWFsSW1hZ2VEYXRhLnNjYWxlWSA9IDE7XG4gICAgICB9XG4gICAgICBfdGhpczIuaW1hZ2VEYXRhID0gaW1hZ2VEYXRhO1xuICAgICAgX3RoaXMyLmluaXRpYWxJbWFnZURhdGEgPSBpbml0aWFsSW1hZ2VEYXRhO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICByZW5kZXJJbWFnZTogZnVuY3Rpb24gcmVuZGVySW1hZ2UoZG9uZSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2UsXG4gICAgICBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTtcbiAgICBzZXRTdHlsZShpbWFnZSwgYXNzaWduKHtcbiAgICAgIHdpZHRoOiBpbWFnZURhdGEud2lkdGgsXG4gICAgICBoZWlnaHQ6IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAvLyBYWFg6IE5vdCB0byB1c2UgdHJhbnNsYXRlWC9ZIHRvIGF2b2lkIGltYWdlIHNoYWtpbmcgd2hlbiB6b29taW5nXG4gICAgICBtYXJnaW5MZWZ0OiBpbWFnZURhdGEueCxcbiAgICAgIG1hcmdpblRvcDogaW1hZ2VEYXRhLnlcbiAgICB9LCBnZXRUcmFuc2Zvcm1zKGltYWdlRGF0YSkpKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgaWYgKCh0aGlzLnZpZXdpbmcgfHwgdGhpcy5tb3ZpbmcgfHwgdGhpcy5yb3RhdGluZyB8fCB0aGlzLnNjYWxpbmcgfHwgdGhpcy56b29taW5nKSAmJiB0aGlzLm9wdGlvbnMudHJhbnNpdGlvbiAmJiBoYXNDbGFzcyhpbWFnZSwgQ0xBU1NfVFJBTlNJVElPTikpIHtcbiAgICAgICAgdmFyIG9uVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZCgpIHtcbiAgICAgICAgICBfdGhpczMuaW1hZ2VSZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW1hZ2VSZW5kZXJpbmcgPSB7XG4gICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX1RSQU5TSVRJT05fRU5ELCBvblRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYWRkTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX1RSQU5TSVRJT05fRU5ELCBvblRyYW5zaXRpb25FbmQsIHtcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmVzZXRJbWFnZTogZnVuY3Rpb24gcmVzZXRJbWFnZSgpIHtcbiAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgIGlmIChpbWFnZSkge1xuICAgICAgaWYgKHRoaXMudmlld2luZykge1xuICAgICAgICB0aGlzLnZpZXdpbmcuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGltYWdlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1hZ2UpO1xuICAgICAgdGhpcy5pbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLnRpdGxlLmlubmVySFRNTCA9ICcnO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGV2ZW50cyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIHZpZXdlciA9IHRoaXMudmlld2VyLFxuICAgICAgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgYWRkTGlzdGVuZXIodmlld2VyLCBFVkVOVF9DTElDSywgdGhpcy5vbkNsaWNrID0gdGhpcy5jbGljay5iaW5kKHRoaXMpKTtcbiAgICBhZGRMaXN0ZW5lcih2aWV3ZXIsIEVWRU5UX0RSQUdfU1RBUlQsIHRoaXMub25EcmFnU3RhcnQgPSB0aGlzLmRyYWdzdGFydC5iaW5kKHRoaXMpKTtcbiAgICBhZGRMaXN0ZW5lcihjYW52YXMsIEVWRU5UX1BPSU5URVJfRE9XTiwgdGhpcy5vblBvaW50ZXJEb3duID0gdGhpcy5wb2ludGVyZG93bi5iaW5kKHRoaXMpKTtcbiAgICBhZGRMaXN0ZW5lcihkb2N1bWVudCwgRVZFTlRfUE9JTlRFUl9NT1ZFLCB0aGlzLm9uUG9pbnRlck1vdmUgPSB0aGlzLnBvaW50ZXJtb3ZlLmJpbmQodGhpcykpO1xuICAgIGFkZExpc3RlbmVyKGRvY3VtZW50LCBFVkVOVF9QT0lOVEVSX1VQLCB0aGlzLm9uUG9pbnRlclVwID0gdGhpcy5wb2ludGVydXAuYmluZCh0aGlzKSk7XG4gICAgYWRkTGlzdGVuZXIoZG9jdW1lbnQsIEVWRU5UX0tFWV9ET1dOLCB0aGlzLm9uS2V5RG93biA9IHRoaXMua2V5ZG93bi5iaW5kKHRoaXMpKTtcbiAgICBhZGRMaXN0ZW5lcih3aW5kb3csIEVWRU5UX1JFU0laRSwgdGhpcy5vblJlc2l6ZSA9IHRoaXMucmVzaXplLmJpbmQodGhpcykpO1xuICAgIGlmIChvcHRpb25zLnpvb21hYmxlICYmIG9wdGlvbnMuem9vbU9uV2hlZWwpIHtcbiAgICAgIGFkZExpc3RlbmVyKHZpZXdlciwgRVZFTlRfV0hFRUwsIHRoaXMub25XaGVlbCA9IHRoaXMud2hlZWwuYmluZCh0aGlzKSwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRvZ2dsZU9uRGJsY2xpY2spIHtcbiAgICAgIGFkZExpc3RlbmVyKGNhbnZhcywgRVZFTlRfREJMQ0xJQ0ssIHRoaXMub25EYmxjbGljayA9IHRoaXMuZGJsY2xpY2suYmluZCh0aGlzKSk7XG4gICAgfVxuICB9LFxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIHZpZXdlciA9IHRoaXMudmlld2VyLFxuICAgICAgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgcmVtb3ZlTGlzdGVuZXIodmlld2VyLCBFVkVOVF9DTElDSywgdGhpcy5vbkNsaWNrKTtcbiAgICByZW1vdmVMaXN0ZW5lcih2aWV3ZXIsIEVWRU5UX0RSQUdfU1RBUlQsIHRoaXMub25EcmFnU3RhcnQpO1xuICAgIHJlbW92ZUxpc3RlbmVyKGNhbnZhcywgRVZFTlRfUE9JTlRFUl9ET1dOLCB0aGlzLm9uUG9pbnRlckRvd24pO1xuICAgIHJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCBFVkVOVF9QT0lOVEVSX01PVkUsIHRoaXMub25Qb2ludGVyTW92ZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoZG9jdW1lbnQsIEVWRU5UX1BPSU5URVJfVVAsIHRoaXMub25Qb2ludGVyVXApO1xuICAgIHJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCBFVkVOVF9LRVlfRE9XTiwgdGhpcy5vbktleURvd24pO1xuICAgIHJlbW92ZUxpc3RlbmVyKHdpbmRvdywgRVZFTlRfUkVTSVpFLCB0aGlzLm9uUmVzaXplKTtcbiAgICBpZiAob3B0aW9ucy56b29tYWJsZSAmJiBvcHRpb25zLnpvb21PbldoZWVsKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcih2aWV3ZXIsIEVWRU5UX1dIRUVMLCB0aGlzLm9uV2hlZWwsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50b2dnbGVPbkRibGNsaWNrKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihjYW52YXMsIEVWRU5UX0RCTENMSUNLLCB0aGlzLm9uRGJsY2xpY2spO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGhhbmRsZXJzID0ge1xuICBjbGljazogZnVuY3Rpb24gY2xpY2soZXZlbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhO1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGFjdGlvbiA9IGdldERhdGEodGFyZ2V0LCBEQVRBX0FDVElPTik7XG4gICAgaWYgKCFhY3Rpb24gJiYgdGFyZ2V0LmxvY2FsTmFtZSA9PT0gJ2ltZycgJiYgdGFyZ2V0LnBhcmVudEVsZW1lbnQubG9jYWxOYW1lID09PSAnbGknKSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICAgIGFjdGlvbiA9IGdldERhdGEodGFyZ2V0LCBEQVRBX0FDVElPTik7XG4gICAgfVxuXG4gICAgLy8gQ2FuY2VsIHRoZSBlbXVsYXRlZCBjbGljayB3aGVuIHRoZSBuYXRpdmUgY2xpY2sgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICBpZiAoSVNfVE9VQ0hfREVWSUNFICYmIGV2ZW50LmlzVHJ1c3RlZCAmJiB0YXJnZXQgPT09IHRoaXMuY2FudmFzKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jbGlja0NhbnZhc1RpbWVvdXQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSAnbWl4JzpcbiAgICAgICAgaWYgKHRoaXMucGxheWVkKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmxpbmUpIHtcbiAgICAgICAgICBpZiAodGhpcy5mdWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhpdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZ1bGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdoaWRlJzpcbiAgICAgICAgaWYgKCF0aGlzLnBvaW50ZXJNb3ZlZCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndmlldyc6XG4gICAgICAgIHRoaXMudmlldyhnZXREYXRhKHRhcmdldCwgJ2luZGV4JykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3pvb20taW4nOlxuICAgICAgICB0aGlzLnpvb20oMC4xLCB0cnVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd6b29tLW91dCc6XG4gICAgICAgIHRoaXMuem9vbSgtMC4xLCB0cnVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvbmUtdG8tb25lJzpcbiAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZXNldCc6XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwcmV2JzpcbiAgICAgICAgdGhpcy5wcmV2KG9wdGlvbnMubG9vcCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncGxheSc6XG4gICAgICAgIHRoaXMucGxheShvcHRpb25zLmZ1bGxzY3JlZW4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ25leHQnOlxuICAgICAgICB0aGlzLm5leHQob3B0aW9ucy5sb29wKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyb3RhdGUtbGVmdCc6XG4gICAgICAgIHRoaXMucm90YXRlKC05MCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncm90YXRlLXJpZ2h0JzpcbiAgICAgICAgdGhpcy5yb3RhdGUoOTApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ZsaXAtaG9yaXpvbnRhbCc6XG4gICAgICAgIHRoaXMuc2NhbGVYKC1pbWFnZURhdGEuc2NhbGVYIHx8IC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmbGlwLXZlcnRpY2FsJzpcbiAgICAgICAgdGhpcy5zY2FsZVkoLWltYWdlRGF0YS5zY2FsZVkgfHwgLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0aGlzLnBsYXllZCkge1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICB9LFxuICBkYmxjbGljazogZnVuY3Rpb24gZGJsY2xpY2soZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICh0aGlzLnZpZXdlZCAmJiBldmVudC50YXJnZXQgPT09IHRoaXMuaW1hZ2UpIHtcbiAgICAgIC8vIENhbmNlbCB0aGUgZW11bGF0ZWQgZG91YmxlIGNsaWNrIHdoZW4gdGhlIG5hdGl2ZSBkYmxjbGljayBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAgaWYgKElTX1RPVUNIX0RFVklDRSAmJiBldmVudC5pc1RydXN0ZWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlQ2xpY2tJbWFnZVRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBYWFg6IE5vIHBhZ2VYL1kgcHJvcGVydGllcyBpbiBjdXN0b20gZXZlbnQsIGZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCBldmVudC5cbiAgICAgIHRoaXMudG9nZ2xlKGV2ZW50LmlzVHJ1c3RlZCA/IGV2ZW50IDogZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC5vcmlnaW5hbEV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgIHRoaXMudGltZW91dCA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBpbWFnZSA9IHRoaXMuaW1hZ2UsXG4gICAgICBpbmRleCA9IHRoaXMuaW5kZXgsXG4gICAgICB2aWV3ZXJEYXRhID0gdGhpcy52aWV3ZXJEYXRhO1xuICAgIHJlbW92ZUNsYXNzKGltYWdlLCBDTEFTU19JTlZJU0lCTEUpO1xuICAgIGlmIChvcHRpb25zLmxvYWRpbmcpIHtcbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuY2FudmFzLCBDTEFTU19MT0FESU5HKTtcbiAgICB9XG4gICAgaW1hZ2Uuc3R5bGUuY3NzVGV4dCA9ICdoZWlnaHQ6MDsnICsgXCJtYXJnaW4tbGVmdDpcIi5jb25jYXQodmlld2VyRGF0YS53aWR0aCAvIDIsIFwicHg7XCIpICsgXCJtYXJnaW4tdG9wOlwiLmNvbmNhdCh2aWV3ZXJEYXRhLmhlaWdodCAvIDIsIFwicHg7XCIpICsgJ21heC13aWR0aDpub25lIWltcG9ydGFudDsnICsgJ3Bvc2l0aW9uOnJlbGF0aXZlOycgKyAnd2lkdGg6MDsnO1xuICAgIHRoaXMuaW5pdEltYWdlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRvZ2dsZUNsYXNzKGltYWdlLCBDTEFTU19NT1ZFLCBvcHRpb25zLm1vdmFibGUpO1xuICAgICAgdG9nZ2xlQ2xhc3MoaW1hZ2UsIENMQVNTX1RSQU5TSVRJT04sIG9wdGlvbnMudHJhbnNpdGlvbik7XG4gICAgICBfdGhpcy5yZW5kZXJJbWFnZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnZpZXdlZCA9IHRydWU7XG4gICAgICAgIF90aGlzLnZpZXdpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy52aWV3ZWQpKSB7XG4gICAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfVklFV0VELCBvcHRpb25zLnZpZXdlZCwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfVklFV0VELCB7XG4gICAgICAgICAgb3JpZ2luYWxJbWFnZTogX3RoaXMuaW1hZ2VzW2luZGV4XSxcbiAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgaW1hZ2U6IGltYWdlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBsb2FkSW1hZ2U6IGZ1bmN0aW9uIGxvYWRJbWFnZShldmVudCkge1xuICAgIHZhciBpbWFnZSA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgcGFyZW50ID0gaW1hZ2UucGFyZW50Tm9kZTtcbiAgICB2YXIgcGFyZW50V2lkdGggPSBwYXJlbnQub2Zmc2V0V2lkdGggfHwgMzA7XG4gICAgdmFyIHBhcmVudEhlaWdodCA9IHBhcmVudC5vZmZzZXRIZWlnaHQgfHwgNTA7XG4gICAgdmFyIGZpbGxlZCA9ICEhZ2V0RGF0YShpbWFnZSwgJ2ZpbGxlZCcpO1xuICAgIGdldEltYWdlTmF0dXJhbFNpemVzKGltYWdlLCB0aGlzLm9wdGlvbnMsIGZ1bmN0aW9uIChuYXR1cmFsV2lkdGgsIG5hdHVyYWxIZWlnaHQpIHtcbiAgICAgIHZhciBhc3BlY3RSYXRpbyA9IG5hdHVyYWxXaWR0aCAvIG5hdHVyYWxIZWlnaHQ7XG4gICAgICB2YXIgd2lkdGggPSBwYXJlbnRXaWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBwYXJlbnRIZWlnaHQ7XG4gICAgICBpZiAocGFyZW50SGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBwYXJlbnRXaWR0aCkge1xuICAgICAgICBpZiAoZmlsbGVkKSB7XG4gICAgICAgICAgd2lkdGggPSBwYXJlbnRIZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWlnaHQgPSBwYXJlbnRXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpbGxlZCkge1xuICAgICAgICBoZWlnaHQgPSBwYXJlbnRXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSBwYXJlbnRIZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgIH1cbiAgICAgIHNldFN0eWxlKGltYWdlLCBhc3NpZ24oe1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9LCBnZXRUcmFuc2Zvcm1zKHtcbiAgICAgICAgdHJhbnNsYXRlWDogKHBhcmVudFdpZHRoIC0gd2lkdGgpIC8gMixcbiAgICAgICAgdHJhbnNsYXRlWTogKHBhcmVudEhlaWdodCAtIGhlaWdodCkgLyAyXG4gICAgICB9KSkpO1xuICAgIH0pO1xuICB9LFxuICBrZXlkb3duOiBmdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFvcHRpb25zLmtleWJvYXJkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZSB8fCBldmVudC53aGljaCB8fCBldmVudC5jaGFyQ29kZTtcbiAgICBzd2l0Y2ggKGtleUNvZGUpIHtcbiAgICAgIC8vIEVudGVyXG4gICAgICBjYXNlIDEzOlxuICAgICAgICBpZiAodGhpcy52aWV3ZXIuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgIHRoaXMuY2xpY2soZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZnVsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgLy8gRXNjYXBlXG4gICAgICBjYXNlIDI3OlxuICAgICAgICBpZiAodGhpcy5wbGF5ZWQpIHtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmlubGluZSkge1xuICAgICAgICAgIGlmICh0aGlzLmZ1bGxlZCkge1xuICAgICAgICAgICAgdGhpcy5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBTcGFjZVxuICAgICAgY2FzZSAzMjpcbiAgICAgICAgaWYgKHRoaXMucGxheWVkKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIEFycm93TGVmdFxuICAgICAgY2FzZSAzNzpcbiAgICAgICAgaWYgKHRoaXMucGxheWVkICYmIHRoaXMucGxheWluZykge1xuICAgICAgICAgIHRoaXMucGxheWluZy5wcmV2KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wcmV2KG9wdGlvbnMubG9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIEFycm93VXBcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsIG9uIEZpcmVmb3hcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBab29tIGluXG4gICAgICAgIHRoaXMuem9vbShvcHRpb25zLnpvb21SYXRpbywgdHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBBcnJvd1JpZ2h0XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBpZiAodGhpcy5wbGF5ZWQgJiYgdGhpcy5wbGF5aW5nKSB7XG4gICAgICAgICAgdGhpcy5wbGF5aW5nLm5leHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm5leHQob3B0aW9ucy5sb29wKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgLy8gQXJyb3dEb3duXG4gICAgICBjYXNlIDQwOlxuICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbCBvbiBGaXJlZm94XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gWm9vbSBvdXRcbiAgICAgICAgdGhpcy56b29tKC1vcHRpb25zLnpvb21SYXRpbywgdHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBDdHJsICsgMFxuICAgICAgY2FzZSA0ODpcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICAvLyBDdHJsICsgMVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICBjYXNlIDQ5OlxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG4gIGRyYWdzdGFydDogZnVuY3Rpb24gZHJhZ3N0YXJ0KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldC5sb2NhbE5hbWUgPT09ICdpbWcnKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcbiAgcG9pbnRlcmRvd246IGZ1bmN0aW9uIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBwb2ludGVycyA9IHRoaXMucG9pbnRlcnM7XG4gICAgdmFyIGJ1dHRvbnMgPSBldmVudC5idXR0b25zLFxuICAgICAgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICAgIHRoaXMucG9pbnRlck1vdmVkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLnZpZXdlZCB8fCB0aGlzLnNob3dpbmcgfHwgdGhpcy52aWV3aW5nIHx8IHRoaXMuaGlkaW5nXG5cbiAgICAvLyBIYW5kbGUgbW91c2UgZXZlbnQgYW5kIHBvaW50ZXIgZXZlbnQgYW5kIGlnbm9yZSB0b3VjaCBldmVudFxuICAgIHx8IChldmVudC50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldmVudC50eXBlID09PSAncG9pbnRlcmRvd24nICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSAmJiAoXG4gICAgLy8gTm8gcHJpbWFyeSBidXR0b24gKFVzdWFsbHkgdGhlIGxlZnQgYnV0dG9uKVxuICAgIGlzTnVtYmVyKGJ1dHRvbnMpICYmIGJ1dHRvbnMgIT09IDEgfHwgaXNOdW1iZXIoYnV0dG9uKSAmJiBidXR0b24gIT09IDBcblxuICAgIC8vIE9wZW4gY29udGV4dCBtZW51XG4gICAgfHwgZXZlbnQuY3RybEtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3VycyBhcyBwYWdlIHpvb21pbmcgaW4gdG91Y2ggZGV2aWNlcy5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgZm9yRWFjaChldmVudC5jaGFuZ2VkVG91Y2hlcywgZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICAgIHBvaW50ZXJzW3RvdWNoLmlkZW50aWZpZXJdID0gZ2V0UG9pbnRlcih0b3VjaCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlcnNbZXZlbnQucG9pbnRlcklkIHx8IDBdID0gZ2V0UG9pbnRlcihldmVudCk7XG4gICAgfVxuICAgIHZhciBhY3Rpb24gPSBvcHRpb25zLm1vdmFibGUgPyBBQ1RJT05fTU9WRSA6IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLnpvb21PblRvdWNoICYmIG9wdGlvbnMuem9vbWFibGUgJiYgT2JqZWN0LmtleXMocG9pbnRlcnMpLmxlbmd0aCA+IDEpIHtcbiAgICAgIGFjdGlvbiA9IEFDVElPTl9aT09NO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zbGlkZU9uVG91Y2ggJiYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnIHx8IGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JykgJiYgdGhpcy5pc1N3aXRjaGFibGUoKSkge1xuICAgICAgYWN0aW9uID0gQUNUSU9OX1NXSVRDSDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbiAmJiAoYWN0aW9uID09PSBBQ1RJT05fTU9WRSB8fCBhY3Rpb24gPT09IEFDVElPTl9aT09NKSkge1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5pbWFnZSwgQ0xBU1NfVFJBTlNJVElPTik7XG4gICAgfVxuICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uO1xuICB9LFxuICBwb2ludGVybW92ZTogZnVuY3Rpb24gcG9pbnRlcm1vdmUoZXZlbnQpIHtcbiAgICB2YXIgcG9pbnRlcnMgPSB0aGlzLnBvaW50ZXJzLFxuICAgICAgYWN0aW9uID0gdGhpcy5hY3Rpb247XG4gICAgaWYgKCF0aGlzLnZpZXdlZCB8fCAhYWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICBmb3JFYWNoKGV2ZW50LmNoYW5nZWRUb3VjaGVzLCBmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgICAgYXNzaWduKHBvaW50ZXJzW3RvdWNoLmlkZW50aWZpZXJdIHx8IHt9LCBnZXRQb2ludGVyKHRvdWNoLCB0cnVlKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduKHBvaW50ZXJzW2V2ZW50LnBvaW50ZXJJZCB8fCAwXSB8fCB7fSwgZ2V0UG9pbnRlcihldmVudCwgdHJ1ZSkpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZShldmVudCk7XG4gIH0sXG4gIHBvaW50ZXJ1cDogZnVuY3Rpb24gcG9pbnRlcnVwKGV2ZW50KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBhY3Rpb24gPSB0aGlzLmFjdGlvbixcbiAgICAgIHBvaW50ZXJzID0gdGhpcy5wb2ludGVycztcbiAgICB2YXIgcG9pbnRlcjtcbiAgICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgIGZvckVhY2goZXZlbnQuY2hhbmdlZFRvdWNoZXMsIGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgICBwb2ludGVyID0gcG9pbnRlcnNbdG91Y2guaWRlbnRpZmllcl07XG4gICAgICAgIGRlbGV0ZSBwb2ludGVyc1t0b3VjaC5pZGVudGlmaWVyXTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVyID0gcG9pbnRlcnNbZXZlbnQucG9pbnRlcklkIHx8IDBdO1xuICAgICAgZGVsZXRlIHBvaW50ZXJzW2V2ZW50LnBvaW50ZXJJZCB8fCAwXTtcbiAgICB9XG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uICYmIChhY3Rpb24gPT09IEFDVElPTl9NT1ZFIHx8IGFjdGlvbiA9PT0gQUNUSU9OX1pPT00pKSB7XG4gICAgICBhZGRDbGFzcyh0aGlzLmltYWdlLCBDTEFTU19UUkFOU0lUSU9OKTtcbiAgICB9XG4gICAgdGhpcy5hY3Rpb24gPSBmYWxzZTtcblxuICAgIC8vIEVtdWxhdGUgY2xpY2sgYW5kIGRvdWJsZSBjbGljayBpbiB0b3VjaCBkZXZpY2VzIHRvIHN1cHBvcnQgYmFja2Ryb3AgYW5kIGltYWdlIHpvb21pbmcgKCMyMTApLlxuICAgIGlmIChJU19UT1VDSF9ERVZJQ0UgJiYgYWN0aW9uICE9PSBBQ1RJT05fWk9PTSAmJiBwb2ludGVyICYmIERhdGUubm93KCkgLSBwb2ludGVyLnRpbWVTdGFtcCA8IDUwMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xpY2tDYW52YXNUaW1lb3V0KTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRvdWJsZUNsaWNrSW1hZ2VUaW1lb3V0KTtcbiAgICAgIGlmIChvcHRpb25zLnRvZ2dsZU9uRGJsY2xpY2sgJiYgdGhpcy52aWV3ZWQgJiYgZXZlbnQudGFyZ2V0ID09PSB0aGlzLmltYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlQ2xpY2tlZCkge1xuICAgICAgICAgIHRoaXMuaW1hZ2VDbGlja2VkID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBUaGlzIHRpbWVvdXQgd2lsbCBiZSBjbGVhcmVkIGxhdGVyIHdoZW4gYSBuYXRpdmUgZGJsY2xpY2sgZXZlbnQgaXMgdHJpZ2dlcmluZ1xuICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tJbWFnZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoX3RoaXMyLmltYWdlLCBFVkVOVF9EQkxDTElDSywge1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgNTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW1hZ2VDbGlja2VkID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHRpbWluZyBvZiBhIGRvdWJsZSBjbGljayBpbiBXaW5kb3dzIGlzIDUwMCBtc1xuICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tJbWFnZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5pbWFnZUNsaWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmltYWdlQ2xpY2tlZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0aW9ucy5iYWNrZHJvcCAmJiBvcHRpb25zLmJhY2tkcm9wICE9PSAnc3RhdGljJyAmJiBldmVudC50YXJnZXQgPT09IHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgLy8gVGhpcyB0aW1lb3V0IHdpbGwgYmUgY2xlYXJlZCBsYXRlciB3aGVuIGEgbmF0aXZlIGNsaWNrIGV2ZW50IGlzIHRyaWdnZXJpbmdcbiAgICAgICAgICB0aGlzLmNsaWNrQ2FudmFzVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hFdmVudChfdGhpczIuY2FudmFzLCBFVkVOVF9DTElDSywge1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgNTApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICBpZiAoIXRoaXMuaXNTaG93biB8fCB0aGlzLmhpZGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5mdWxsZWQpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIHRoaXMuaW5pdEJvZHkoKTtcbiAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgICB0aGlzLmluaXRDb250YWluZXIoKTtcbiAgICB0aGlzLmluaXRWaWV3ZXIoKTtcbiAgICB0aGlzLnJlbmRlclZpZXdlcigpO1xuICAgIHRoaXMucmVuZGVyTGlzdCgpO1xuICAgIGlmICh0aGlzLnZpZXdlZCkge1xuICAgICAgdGhpcy5pbml0SW1hZ2UoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMucmVuZGVySW1hZ2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5wbGF5ZWQpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZnVsbHNjcmVlbiAmJiB0aGlzLmZ1bGxlZCAmJiAhKGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3JFYWNoKHRoaXMucGxheWVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKSwgZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGltYWdlLCBFVkVOVF9MT0FELCBfdGhpczMubG9hZEltYWdlLmJpbmQoX3RoaXMzKSwge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGRpc3BhdGNoRXZlbnQoaW1hZ2UsIEVWRU5UX0xPQUQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICB3aGVlbDogZnVuY3Rpb24gd2hlZWwoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICBpZiAoIXRoaXMudmlld2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAvLyBMaW1pdCB3aGVlbCBzcGVlZCB0byBwcmV2ZW50IHpvb20gdG9vIGZhc3RcbiAgICBpZiAodGhpcy53aGVlbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndoZWVsaW5nID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzNC53aGVlbGluZyA9IGZhbHNlO1xuICAgIH0sIDUwKTtcbiAgICB2YXIgcmF0aW8gPSBOdW1iZXIodGhpcy5vcHRpb25zLnpvb21SYXRpbykgfHwgMC4xO1xuICAgIHZhciBkZWx0YSA9IDE7XG4gICAgaWYgKGV2ZW50LmRlbHRhWSkge1xuICAgICAgZGVsdGEgPSBldmVudC5kZWx0YVkgPiAwID8gMSA6IC0xO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hlZWxEZWx0YSkge1xuICAgICAgZGVsdGEgPSAtZXZlbnQud2hlZWxEZWx0YSAvIDEyMDtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbCkge1xuICAgICAgZGVsdGEgPSBldmVudC5kZXRhaWwgPiAwID8gMSA6IC0xO1xuICAgIH1cbiAgICB0aGlzLnpvb20oLWRlbHRhICogcmF0aW8sIHRydWUsIG51bGwsIGV2ZW50KTtcbiAgfVxufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8qKiBTaG93IHRoZSB2aWV3ZXIgKG9ubHkgYXZhaWxhYmxlIGluIG1vZGFsIG1vZGUpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltbWVkaWF0ZT1mYWxzZV0gLSBJbmRpY2F0ZXMgaWYgc2hvdyB0aGUgdmlld2VyIGltbWVkaWF0ZWx5IG9yIG5vdC5cbiAgICogQHJldHVybnMge1ZpZXdlcn0gdGhpc1xuICAgKi9cbiAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICB2YXIgaW1tZWRpYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuaW5saW5lIHx8IHRoaXMuc2hvd2luZyB8fCB0aGlzLmlzU2hvd24gfHwgdGhpcy5zaG93aW5nKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCF0aGlzLnJlYWR5KSB7XG4gICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICB0aGlzLnNob3coaW1tZWRpYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnNob3cpKSB7XG4gICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9TSE9XLCBvcHRpb25zLnNob3csIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIEVWRU5UX1NIT1cpID09PSBmYWxzZSB8fCAhdGhpcy5yZWFkeSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLmhpZGluZykge1xuICAgICAgdGhpcy50cmFuc2l0aW9uaW5nLmFib3J0KCk7XG4gICAgfVxuICAgIHRoaXMuc2hvd2luZyA9IHRydWU7XG4gICAgdGhpcy5vcGVuKCk7XG4gICAgdmFyIHZpZXdlciA9IHRoaXMudmlld2VyO1xuICAgIHJlbW92ZUNsYXNzKHZpZXdlciwgQ0xBU1NfSElERSk7XG4gICAgdmlld2VyLnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcbiAgICB2aWV3ZXIuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknLCB0aGlzLnRpdGxlLmlkKTtcbiAgICB2aWV3ZXIuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSk7XG4gICAgdmlld2VyLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uICYmICFpbW1lZGlhdGUpIHtcbiAgICAgIHZhciBzaG93biA9IHRoaXMuc2hvd24uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IHtcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKHZpZXdlciwgRVZFTlRfVFJBTlNJVElPTl9FTkQsIHNob3duKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyh2aWV3ZXIsIENMQVNTX0lOKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGFkZENsYXNzKHZpZXdlciwgQ0xBU1NfVFJBTlNJVElPTik7XG5cbiAgICAgIC8vIEZvcmNlIHJlZmxvdyB0byBlbmFibGUgQ1NTMyB0cmFuc2l0aW9uXG4gICAgICB2aWV3ZXIuaW5pdGlhbE9mZnNldFdpZHRoID0gdmlld2VyLm9mZnNldFdpZHRoO1xuICAgICAgYWRkTGlzdGVuZXIodmlld2VyLCBFVkVOVF9UUkFOU0lUSU9OX0VORCwgc2hvd24sIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBhZGRDbGFzcyh2aWV3ZXIsIENMQVNTX0lOKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkQ2xhc3Modmlld2VyLCBDTEFTU19JTik7XG4gICAgICB0aGlzLnNob3duKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogSGlkZSB0aGUgdmlld2VyIChvbmx5IGF2YWlsYWJsZSBpbiBtb2RhbCBtb2RlKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbW1lZGlhdGU9ZmFsc2VdIC0gSW5kaWNhdGVzIGlmIGhpZGUgdGhlIHZpZXdlciBpbW1lZGlhdGVseSBvciBub3QuXG4gICAqIEByZXR1cm5zIHtWaWV3ZXJ9IHRoaXNcbiAgICovXG4gIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgaW1tZWRpYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuaW5saW5lIHx8IHRoaXMuaGlkaW5nIHx8ICEodGhpcy5pc1Nob3duIHx8IHRoaXMuc2hvd2luZykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmhpZGUpKSB7XG4gICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9ISURFLCBvcHRpb25zLmhpZGUsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIEVWRU5UX0hJREUpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLnNob3dpbmcpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbmluZy5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLmhpZGluZyA9IHRydWU7XG4gICAgaWYgKHRoaXMucGxheWVkKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudmlld2luZykge1xuICAgICAgdGhpcy52aWV3aW5nLmFib3J0KCk7XG4gICAgfVxuICAgIHZhciB2aWV3ZXIgPSB0aGlzLnZpZXdlcixcbiAgICAgIGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICB2YXIgaGlkZUltbWVkaWF0ZWx5ID0gZnVuY3Rpb24gaGlkZUltbWVkaWF0ZWx5KCkge1xuICAgICAgcmVtb3ZlQ2xhc3Modmlld2VyLCBDTEFTU19JTik7XG4gICAgICBfdGhpcy5oaWRkZW4oKTtcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24gJiYgIWltbWVkaWF0ZSkge1xuICAgICAgdmFyIG9uVmlld2VyVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIG9uVmlld2VyVHJhbnNpdGlvbkVuZChldmVudCkge1xuICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BhZ2F0aW5nIGB0cmFuc2l0aW9uZW5kYCBldmVudHMgKCMyNzUpLlxuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQudGFyZ2V0ID09PSB2aWV3ZXIpIHtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcih2aWV3ZXIsIEVWRU5UX1RSQU5TSVRJT05fRU5ELCBvblZpZXdlclRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgIF90aGlzLmhpZGRlbigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIG9uSW1hZ2VUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gb25JbWFnZVRyYW5zaXRpb25FbmQoKSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2Ygc2hvdyB0aGUgdmlld2VyIGJ5IGB2aWV3ZXIuc2hvdyh0cnVlKWAgcHJldmlvdXNseSAoIzQwNykuXG4gICAgICAgIGlmIChoYXNDbGFzcyh2aWV3ZXIsIENMQVNTX1RSQU5TSVRJT04pKSB7XG4gICAgICAgICAgYWRkTGlzdGVuZXIodmlld2VyLCBFVkVOVF9UUkFOU0lUSU9OX0VORCwgb25WaWV3ZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyh2aWV3ZXIsIENMQVNTX0lOKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWRlSW1tZWRpYXRlbHkoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IHtcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICAgIGlmIChfdGhpcy52aWV3ZWQgJiYgaGFzQ2xhc3MoaW1hZ2UsIENMQVNTX1RSQU5TSVRJT04pKSB7XG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihpbWFnZSwgRVZFTlRfVFJBTlNJVElPTl9FTkQsIG9uSW1hZ2VUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NsYXNzKHZpZXdlciwgQ0xBU1NfVFJBTlNJVElPTikpIHtcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKHZpZXdlciwgRVZFTlRfVFJBTlNJVElPTl9FTkQsIG9uVmlld2VyVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBJbiBjYXNlIG9mIGhpZGluZyB0aGUgdmlld2VyIHdoZW4gaG9sZGluZyBvbiB0aGUgaW1hZ2UgKCMyNTUpLFxuICAgICAgLy8gbm90ZSB0aGF0IHRoZSBgQ0xBU1NfVFJBTlNJVElPTmAgY2xhc3Mgd2lsbCBiZSByZW1vdmVkIG9uIHBvaW50ZXIgZG93bi5cbiAgICAgIGlmICh0aGlzLnZpZXdlZCAmJiBoYXNDbGFzcyhpbWFnZSwgQ0xBU1NfVFJBTlNJVElPTikpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX1RSQU5TSVRJT05fRU5ELCBvbkltYWdlVHJhbnNpdGlvbkVuZCwge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuem9vbVRvKDAsIGZhbHNlLCBudWxsLCBudWxsLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uSW1hZ2VUcmFuc2l0aW9uRW5kKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZGVJbW1lZGlhdGVseSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIFZpZXcgb25lIG9mIHRoZSBpbWFnZXMgd2l0aCBpbWFnZSdzIGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgaW1hZ2UgdG8gdmlldy5cbiAgICogQHJldHVybnMge1ZpZXdlcn0gdGhpc1xuICAgKi9cbiAgdmlldzogZnVuY3Rpb24gdmlldygpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMub3B0aW9ucy5pbml0aWFsVmlld0luZGV4O1xuICAgIGluZGV4ID0gTnVtYmVyKGluZGV4KSB8fCAwO1xuICAgIGlmICh0aGlzLmhpZGluZyB8fCB0aGlzLnBsYXllZCB8fCBpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5sZW5ndGggfHwgdGhpcy52aWV3ZWQgJiYgaW5kZXggPT09IHRoaXMuaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNTaG93bikge1xuICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgcmV0dXJuIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgICBpZiAodGhpcy52aWV3aW5nKSB7XG4gICAgICB0aGlzLnZpZXdpbmcuYWJvcnQoKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgdGl0bGUgPSB0aGlzLnRpdGxlLFxuICAgICAgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zW2luZGV4XTtcbiAgICB2YXIgaW1nID0gaXRlbS5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcbiAgICB2YXIgdXJsID0gZ2V0RGF0YShpbWcsICdvcmlnaW5hbFVybCcpO1xuICAgIHZhciBhbHQgPSBpbWcuZ2V0QXR0cmlidXRlKCdhbHQnKTtcbiAgICB2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICBmb3JFYWNoKG9wdGlvbnMuaW5oZXJpdGVkQXR0cmlidXRlcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGltZy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgaW1hZ2Uuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgaW1hZ2UuYWx0ID0gYWx0O1xuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMudmlldykpIHtcbiAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX1ZJRVcsIG9wdGlvbnMudmlldywge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfVklFVywge1xuICAgICAgb3JpZ2luYWxJbWFnZTogdGhpcy5pbWFnZXNbaW5kZXhdLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgaW1hZ2U6IGltYWdlXG4gICAgfSkgPT09IGZhbHNlIHx8ICF0aGlzLmlzU2hvd24gfHwgdGhpcy5oaWRpbmcgfHwgdGhpcy5wbGF5ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgYWN0aXZlSXRlbSA9IHRoaXMuaXRlbXNbdGhpcy5pbmRleF07XG4gICAgaWYgKGFjdGl2ZUl0ZW0pIHtcbiAgICAgIHJlbW92ZUNsYXNzKGFjdGl2ZUl0ZW0sIENMQVNTX0FDVElWRSk7XG4gICAgICBhY3RpdmVJdGVtLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcpO1xuICAgIH1cbiAgICBhZGRDbGFzcyhpdGVtLCBDTEFTU19BQ1RJVkUpO1xuICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XG4gICAgaWYgKG9wdGlvbnMuZm9jdXMpIHtcbiAgICAgIGl0ZW0uZm9jdXMoKTtcbiAgICB9XG4gICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgIHRoaXMudmlld2VkID0gZmFsc2U7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuaW1hZ2VEYXRhID0ge307XG4gICAgYWRkQ2xhc3MoaW1hZ2UsIENMQVNTX0lOVklTSUJMRSk7XG4gICAgaWYgKG9wdGlvbnMubG9hZGluZykge1xuICAgICAgYWRkQ2xhc3MoY2FudmFzLCBDTEFTU19MT0FESU5HKTtcbiAgICB9XG4gICAgY2FudmFzLmlubmVySFRNTCA9ICcnO1xuICAgIGNhbnZhcy5hcHBlbmRDaGlsZChpbWFnZSk7XG5cbiAgICAvLyBDZW50ZXIgY3VycmVudCBpdGVtXG4gICAgdGhpcy5yZW5kZXJMaXN0KCk7XG5cbiAgICAvLyBDbGVhciB0aXRsZVxuICAgIHRpdGxlLmlubmVySFRNTCA9ICcnO1xuXG4gICAgLy8gR2VuZXJhdGUgdGl0bGUgYWZ0ZXIgdmlld2VkXG4gICAgdmFyIG9uVmlld2VkID0gZnVuY3Rpb24gb25WaWV3ZWQoKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gX3RoaXMyLmltYWdlRGF0YTtcbiAgICAgIHZhciByZW5kZXIgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMudGl0bGUpID8gb3B0aW9ucy50aXRsZVsxXSA6IG9wdGlvbnMudGl0bGU7XG4gICAgICB0aXRsZS5pbm5lckhUTUwgPSBlc2NhcGVIVE1MRW50aXRpZXMoaXNGdW5jdGlvbihyZW5kZXIpID8gcmVuZGVyLmNhbGwoX3RoaXMyLCBpbWFnZSwgaW1hZ2VEYXRhKSA6IFwiXCIuY29uY2F0KGFsdCwgXCIgKFwiKS5jb25jYXQoaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aCwgXCIgXFx4RDcgXCIpLmNvbmNhdChpbWFnZURhdGEubmF0dXJhbEhlaWdodCwgXCIpXCIpKTtcbiAgICB9O1xuICAgIHZhciBvbkxvYWQ7XG4gICAgdmFyIG9uRXJyb3I7XG4gICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfVklFV0VELCBvblZpZXdlZCwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMudmlld2luZyA9IHtcbiAgICAgIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfVklFV0VELCBvblZpZXdlZCk7XG4gICAgICAgIGlmIChpbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgIGlmIChfdGhpczIuaW1hZ2VSZW5kZXJpbmcpIHtcbiAgICAgICAgICAgIF90aGlzMi5pbWFnZVJlbmRlcmluZy5hYm9ydCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMyLmltYWdlSW5pdGlhbGl6aW5nKSB7XG4gICAgICAgICAgICBfdGhpczIuaW1hZ2VJbml0aWFsaXppbmcuYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2FuY2VsIGRvd25sb2FkIHRvIHNhdmUgYmFuZHdpZHRoLlxuICAgICAgICAgIGltYWdlLnNyYyA9ICcnO1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGltYWdlLCBFVkVOVF9MT0FELCBvbkxvYWQpO1xuICAgICAgICAgIGlmIChfdGhpczIudGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzMi50aW1lb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpbWFnZS5jb21wbGV0ZSkge1xuICAgICAgdGhpcy5sb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZExpc3RlbmVyKGltYWdlLCBFVkVOVF9MT0FELCBvbkxvYWQgPSBmdW5jdGlvbiBvbkxvYWQoKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGltYWdlLCBFVkVOVF9FUlJPUiwgb25FcnJvcik7XG4gICAgICAgIF90aGlzMi5sb2FkKCk7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgYWRkTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0VSUk9SLCBvbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcigpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0xPQUQsIG9uTG9hZCk7XG4gICAgICAgIGlmIChfdGhpczIudGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpczIudGltZW91dCk7XG4gICAgICAgICAgX3RoaXMyLnRpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVDbGFzcyhpbWFnZSwgQ0xBU1NfSU5WSVNJQkxFKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubG9hZGluZykge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKF90aGlzMi5jYW52YXMsIENMQVNTX0xPQURJTkcpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSB0aGUgaW1hZ2UgdmlzaWJsZSBpZiBpdCBmYWlscyB0byBsb2FkIHdpdGhpbiAxc1xuICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKGltYWdlLCBDTEFTU19JTlZJU0lCTEUpO1xuICAgICAgICBfdGhpczIudGltZW91dCA9IGZhbHNlO1xuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogVmlldyB0aGUgcHJldmlvdXMgaW1hZ2VcbiAgICogQHBhcmFtIHtib29sZWFufSBbbG9vcD1mYWxzZV0gLSBJbmRpY2F0ZSBpZiB2aWV3IHRoZSBsYXN0IG9uZVxuICAgKiB3aGVuIGl0IGlzIHRoZSBmaXJzdCBvbmUgYXQgcHJlc2VudC5cbiAgICogQHJldHVybnMge1ZpZXdlcn0gdGhpc1xuICAgKi9cbiAgcHJldjogZnVuY3Rpb24gcHJldigpIHtcbiAgICB2YXIgbG9vcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCAtIDE7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggPSBsb29wID8gdGhpcy5sZW5ndGggLSAxIDogMDtcbiAgICB9XG4gICAgdGhpcy52aWV3KGluZGV4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIFZpZXcgdGhlIG5leHQgaW1hZ2VcbiAgICogQHBhcmFtIHtib29sZWFufSBbbG9vcD1mYWxzZV0gLSBJbmRpY2F0ZSBpZiB2aWV3IHRoZSBmaXJzdCBvbmVcbiAgICogd2hlbiBpdCBpcyB0aGUgbGFzdCBvbmUgYXQgcHJlc2VudC5cbiAgICogQHJldHVybnMge1ZpZXdlcn0gdGhpc1xuICAgKi9cbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgbG9vcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgdmFyIG1heEluZGV4ID0gdGhpcy5sZW5ndGggLSAxO1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXggKyAxO1xuICAgIGlmIChpbmRleCA+IG1heEluZGV4KSB7XG4gICAgICBpbmRleCA9IGxvb3AgPyAwIDogbWF4SW5kZXg7XG4gICAgfVxuICAgIHRoaXMudmlldyhpbmRleCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBpbWFnZSB3aXRoIHJlbGF0aXZlIG9mZnNldHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIG1vdmluZyBkaXN0YW5jZSBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeT14XSBUaGUgbW92aW5nIGRpc3RhbmNlIGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24uXG4gICAqIEByZXR1cm5zIHtWaWV3ZXJ9IHRoaXNcbiAgICovXG4gIG1vdmU6IGZ1bmN0aW9uIG1vdmUoeCkge1xuICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB4O1xuICAgIHZhciBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTtcbiAgICB0aGlzLm1vdmVUbyhpc1VuZGVmaW5lZCh4KSA/IHggOiBpbWFnZURhdGEueCArIE51bWJlcih4KSwgaXNVbmRlZmluZWQoeSkgPyB5IDogaW1hZ2VEYXRhLnkgKyBOdW1iZXIoeSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogTW92ZSB0aGUgaW1hZ2UgdG8gYW4gYWJzb2x1dGUgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIG5ldyBwb3NpdGlvbiBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeT14XSAtIFRoZSBuZXcgcG9zaXRpb24gaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHtFdmVudH0gW19vcmlnaW5hbEV2ZW50PW51bGxdIC0gVGhlIG9yaWdpbmFsIGV2ZW50IGlmIGFueS5cbiAgICogQHJldHVybnMge1ZpZXdlcn0gdGhpc1xuICAgKi9cbiAgbW92ZVRvOiBmdW5jdGlvbiBtb3ZlVG8oeCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB4O1xuICAgIHZhciBfb3JpZ2luYWxFdmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTtcbiAgICB4ID0gTnVtYmVyKHgpO1xuICAgIHkgPSBOdW1iZXIoeSk7XG4gICAgaWYgKHRoaXMudmlld2VkICYmICF0aGlzLnBsYXllZCAmJiBvcHRpb25zLm1vdmFibGUpIHtcbiAgICAgIHZhciBvbGRYID0gaW1hZ2VEYXRhLng7XG4gICAgICB2YXIgb2xkWSA9IGltYWdlRGF0YS55O1xuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSBvbGRYO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IG9sZFk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLm1vdmUpKSB7XG4gICAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfTU9WRSwgb3B0aW9ucy5tb3ZlLCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfTU9WRSwge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBvbGRYOiBvbGRYLFxuICAgICAgICAgIG9sZFk6IG9sZFksXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogX29yaWdpbmFsRXZlbnRcbiAgICAgICAgfSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaW1hZ2VEYXRhLnggPSB4O1xuICAgICAgICBpbWFnZURhdGEueSA9IHk7XG4gICAgICAgIGltYWdlRGF0YS5sZWZ0ID0geDtcbiAgICAgICAgaW1hZ2VEYXRhLnRvcCA9IHk7XG4gICAgICAgIHRoaXMubW92aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZW5kZXJJbWFnZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLm1vdmluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMubW92ZWQpKSB7XG4gICAgICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9NT1ZFRCwgb3B0aW9ucy5tb3ZlZCwge1xuICAgICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlzcGF0Y2hFdmVudChlbGVtZW50LCBFVkVOVF9NT1ZFRCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBvbGRYOiBvbGRYLFxuICAgICAgICAgICAgb2xkWTogb2xkWSxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IF9vcmlnaW5hbEV2ZW50XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogUm90YXRlIHRoZSBpbWFnZSB3aXRoIGEgcmVsYXRpdmUgZGVncmVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVncmVlIC0gVGhlIHJvdGF0ZSBkZWdyZWUuXG4gICAqIEByZXR1cm5zIHtWaWV3ZXJ9IHRoaXNcbiAgICovXG4gIHJvdGF0ZTogZnVuY3Rpb24gcm90YXRlKGRlZ3JlZSkge1xuICAgIHRoaXMucm90YXRlVG8oKHRoaXMuaW1hZ2VEYXRhLnJvdGF0ZSB8fCAwKSArIE51bWJlcihkZWdyZWUpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGUgaW1hZ2UgdG8gYW4gYWJzb2x1dGUgZGVncmVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVncmVlIC0gVGhlIHJvdGF0ZSBkZWdyZWUuXG4gICAqIEByZXR1cm5zIHtWaWV3ZXJ9IHRoaXNcbiAgICovXG4gIHJvdGF0ZVRvOiBmdW5jdGlvbiByb3RhdGVUbyhkZWdyZWUpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTtcbiAgICBkZWdyZWUgPSBOdW1iZXIoZGVncmVlKTtcbiAgICBpZiAoaXNOdW1iZXIoZGVncmVlKSAmJiB0aGlzLnZpZXdlZCAmJiAhdGhpcy5wbGF5ZWQgJiYgb3B0aW9ucy5yb3RhdGFibGUpIHtcbiAgICAgIHZhciBvbGREZWdyZWUgPSBpbWFnZURhdGEucm90YXRlO1xuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5yb3RhdGUpKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX1JPVEFURSwgb3B0aW9ucy5yb3RhdGUsIHtcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfUk9UQVRFLCB7XG4gICAgICAgIGRlZ3JlZTogZGVncmVlLFxuICAgICAgICBvbGREZWdyZWU6IG9sZERlZ3JlZVxuICAgICAgfSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaW1hZ2VEYXRhLnJvdGF0ZSA9IGRlZ3JlZTtcbiAgICAgIHRoaXMucm90YXRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5yZW5kZXJJbWFnZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC5yb3RhdGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnJvdGF0ZWQpKSB7XG4gICAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfUk9UQVRFRCwgb3B0aW9ucy5yb3RhdGVkLCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2hFdmVudChlbGVtZW50LCBFVkVOVF9ST1RBVEVELCB7XG4gICAgICAgICAgZGVncmVlOiBkZWdyZWUsXG4gICAgICAgICAgb2xkRGVncmVlOiBvbGREZWdyZWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogU2NhbGUgdGhlIGltYWdlIG9uIHRoZSB4LWF4aXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVggLSBUaGUgc2NhbGUgcmF0aW8gb24gdGhlIHgtYXhpcy5cbiAgICogQHJldHVybnMge1ZpZXdlcn0gdGhpc1xuICAgKi9cbiAgc2NhbGVYOiBmdW5jdGlvbiBzY2FsZVgoX3NjYWxlWCkge1xuICAgIHRoaXMuc2NhbGUoX3NjYWxlWCwgdGhpcy5pbWFnZURhdGEuc2NhbGVZKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIFNjYWxlIHRoZSBpbWFnZSBvbiB0aGUgeS1heGlzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVZIC0gVGhlIHNjYWxlIHJhdGlvIG9uIHRoZSB5LWF4aXMuXG4gICAqIEByZXR1cm5zIHtWaWV3ZXJ9IHRoaXNcbiAgICovXG4gIHNjYWxlWTogZnVuY3Rpb24gc2NhbGVZKF9zY2FsZVkpIHtcbiAgICB0aGlzLnNjYWxlKHRoaXMuaW1hZ2VEYXRhLnNjYWxlWCwgX3NjYWxlWSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBTY2FsZSB0aGUgaW1hZ2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVggLSBUaGUgc2NhbGUgcmF0aW8gb24gdGhlIHgtYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZVk9c2NhbGVYXSAtIFRoZSBzY2FsZSByYXRpbyBvbiB0aGUgeS1heGlzLlxuICAgKiBAcmV0dXJucyB7Vmlld2VyfSB0aGlzXG4gICAqL1xuICBzY2FsZTogZnVuY3Rpb24gc2NhbGUoc2NhbGVYKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgdmFyIHNjYWxlWSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogc2NhbGVYO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhO1xuICAgIHNjYWxlWCA9IE51bWJlcihzY2FsZVgpO1xuICAgIHNjYWxlWSA9IE51bWJlcihzY2FsZVkpO1xuICAgIGlmICh0aGlzLnZpZXdlZCAmJiAhdGhpcy5wbGF5ZWQgJiYgb3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgdmFyIG9sZFNjYWxlWCA9IGltYWdlRGF0YS5zY2FsZVg7XG4gICAgICB2YXIgb2xkU2NhbGVZID0gaW1hZ2VEYXRhLnNjYWxlWTtcbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICBpZiAoaXNOdW1iZXIoc2NhbGVYKSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjYWxlWCA9IG9sZFNjYWxlWDtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bWJlcihzY2FsZVkpKSB7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVZID0gb2xkU2NhbGVZO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5zY2FsZSkpIHtcbiAgICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9TQ0FMRSwgb3B0aW9ucy5zY2FsZSwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIEVWRU5UX1NDQUxFLCB7XG4gICAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgICAgc2NhbGVZOiBzY2FsZVksXG4gICAgICAgICAgb2xkU2NhbGVYOiBvbGRTY2FsZVgsXG4gICAgICAgICAgb2xkU2NhbGVZOiBvbGRTY2FsZVlcbiAgICAgICAgfSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaW1hZ2VEYXRhLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgaW1hZ2VEYXRhLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgdGhpcy5zY2FsaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZW5kZXJJbWFnZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM1LnNjYWxpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnNjYWxlZCkpIHtcbiAgICAgICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX1NDQUxFRCwgb3B0aW9ucy5zY2FsZWQsIHtcbiAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfU0NBTEVELCB7XG4gICAgICAgICAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICAgICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICAgICAgb2xkU2NhbGVYOiBvbGRTY2FsZVgsXG4gICAgICAgICAgICBvbGRTY2FsZVk6IG9sZFNjYWxlWVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIFpvb20gdGhlIGltYWdlIHdpdGggYSByZWxhdGl2ZSByYXRpby5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIC0gVGhlIHRhcmdldCByYXRpby5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2hvd1Rvb2x0aXA9ZmFsc2VdIC0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gc2hvdyB0aGUgdG9vbHRpcC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwaXZvdF0gLSBUaGUgcGl2b3QgcG9pbnQgY29vcmRpbmF0ZSBmb3Igem9vbWluZy5cbiAgICogQHBhcmFtIHtFdmVudH0gW19vcmlnaW5hbEV2ZW50PW51bGxdIC0gVGhlIG9yaWdpbmFsIGV2ZW50IGlmIGFueS5cbiAgICogQHJldHVybnMge1ZpZXdlcn0gdGhpc1xuICAgKi9cbiAgem9vbTogZnVuY3Rpb24gem9vbShyYXRpbykge1xuICAgIHZhciBzaG93VG9vbHRpcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgdmFyIHBpdm90ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgIHZhciBfb3JpZ2luYWxFdmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICB2YXIgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG4gICAgcmF0aW8gPSBOdW1iZXIocmF0aW8pO1xuICAgIGlmIChyYXRpbyA8IDApIHtcbiAgICAgIHJhdGlvID0gMSAvICgxIC0gcmF0aW8pO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXRpbyA9IDEgKyByYXRpbztcbiAgICB9XG4gICAgdGhpcy56b29tVG8oaW1hZ2VEYXRhLndpZHRoICogcmF0aW8gLyBpbWFnZURhdGEubmF0dXJhbFdpZHRoLCBzaG93VG9vbHRpcCwgcGl2b3QsIF9vcmlnaW5hbEV2ZW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIFpvb20gdGhlIGltYWdlIHRvIGFuIGFic29sdXRlIHJhdGlvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gLSBUaGUgdGFyZ2V0IHJhdGlvLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaG93VG9vbHRpcF0gLSBJbmRpY2F0ZXMgd2hldGhlciB0byBzaG93IHRoZSB0b29sdGlwLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Bpdm90XSAtIFRoZSBwaXZvdCBwb2ludCBjb29yZGluYXRlIGZvciB6b29taW5nLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBbX29yaWdpbmFsRXZlbnQ9bnVsbF0gLSBUaGUgb3JpZ2luYWwgZXZlbnQgaWYgYW55LlxuICAgKiBAcGFyYW0ge0V2ZW50fSBbX3pvb21hYmxlPWZhbHNlXSAtIEluZGljYXRlcyBpZiB0aGUgY3VycmVudCB6b29tIGlzIGF2YWlsYWJsZSBvciBub3QuXG4gICAqIEByZXR1cm5zIHtWaWV3ZXJ9IHRoaXNcbiAgICovXG4gIHpvb21UbzogZnVuY3Rpb24gem9vbVRvKHJhdGlvKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgdmFyIHNob3dUb29sdGlwID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICB2YXIgcGl2b3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgdmFyIF9vcmlnaW5hbEV2ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICAgIHZhciBfem9vbWFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIHBvaW50ZXJzID0gdGhpcy5wb2ludGVycyxcbiAgICAgIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhO1xuICAgIHZhciB4ID0gaW1hZ2VEYXRhLngsXG4gICAgICB5ID0gaW1hZ2VEYXRhLnksXG4gICAgICB3aWR0aCA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICBuYXR1cmFsV2lkdGggPSBpbWFnZURhdGEubmF0dXJhbFdpZHRoLFxuICAgICAgbmF0dXJhbEhlaWdodCA9IGltYWdlRGF0YS5uYXR1cmFsSGVpZ2h0O1xuICAgIHJhdGlvID0gTWF0aC5tYXgoMCwgcmF0aW8pO1xuICAgIGlmIChpc051bWJlcihyYXRpbykgJiYgdGhpcy52aWV3ZWQgJiYgIXRoaXMucGxheWVkICYmIChfem9vbWFibGUgfHwgb3B0aW9ucy56b29tYWJsZSkpIHtcbiAgICAgIGlmICghX3pvb21hYmxlKSB7XG4gICAgICAgIHZhciBtaW5ab29tUmF0aW8gPSBNYXRoLm1heCgwLjAxLCBvcHRpb25zLm1pblpvb21SYXRpbyk7XG4gICAgICAgIHZhciBtYXhab29tUmF0aW8gPSBNYXRoLm1pbigxMDAsIG9wdGlvbnMubWF4Wm9vbVJhdGlvKTtcbiAgICAgICAgcmF0aW8gPSBNYXRoLm1pbihNYXRoLm1heChyYXRpbywgbWluWm9vbVJhdGlvKSwgbWF4Wm9vbVJhdGlvKTtcbiAgICAgIH1cbiAgICAgIGlmIChfb3JpZ2luYWxFdmVudCkge1xuICAgICAgICBzd2l0Y2ggKF9vcmlnaW5hbEV2ZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlICd3aGVlbCc6XG4gICAgICAgICAgICBpZiAob3B0aW9ucy56b29tUmF0aW8gPj0gMC4wNTUgJiYgcmF0aW8gPiAwLjk1ICYmIHJhdGlvIDwgMS4wNSkge1xuICAgICAgICAgICAgICByYXRpbyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdwb2ludGVybW92ZSc6XG4gICAgICAgICAgY2FzZSAndG91Y2htb3ZlJzpcbiAgICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAgICAgaWYgKHJhdGlvID4gMC45OSAmJiByYXRpbyA8IDEuMDEpIHtcbiAgICAgICAgICAgICAgcmF0aW8gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBuZXdXaWR0aCA9IG5hdHVyYWxXaWR0aCAqIHJhdGlvO1xuICAgICAgdmFyIG5ld0hlaWdodCA9IG5hdHVyYWxIZWlnaHQgKiByYXRpbztcbiAgICAgIHZhciBvZmZzZXRXaWR0aCA9IG5ld1dpZHRoIC0gd2lkdGg7XG4gICAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gbmV3SGVpZ2h0IC0gaGVpZ2h0O1xuICAgICAgdmFyIG9sZFJhdGlvID0gaW1hZ2VEYXRhLnJhdGlvO1xuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy56b29tKSkge1xuICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9aT09NLCBvcHRpb25zLnpvb20sIHtcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfWk9PTSwge1xuICAgICAgICByYXRpbzogcmF0aW8sXG4gICAgICAgIG9sZFJhdGlvOiBvbGRSYXRpbyxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogX29yaWdpbmFsRXZlbnRcbiAgICAgIH0pID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuem9vbWluZyA9IHRydWU7XG4gICAgICBpZiAoX29yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGdldE9mZnNldCh0aGlzLnZpZXdlcik7XG4gICAgICAgIHZhciBjZW50ZXIgPSBwb2ludGVycyAmJiBPYmplY3Qua2V5cyhwb2ludGVycykubGVuZ3RoID4gMCA/IGdldFBvaW50ZXJzQ2VudGVyKHBvaW50ZXJzKSA6IHtcbiAgICAgICAgICBwYWdlWDogX29yaWdpbmFsRXZlbnQucGFnZVgsXG4gICAgICAgICAgcGFnZVk6IF9vcmlnaW5hbEV2ZW50LnBhZ2VZXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gWm9vbSBmcm9tIHRoZSB0cmlnZ2VyaW5nIHBvaW50IG9mIHRoZSBldmVudFxuICAgICAgICBpbWFnZURhdGEueCAtPSBvZmZzZXRXaWR0aCAqICgoY2VudGVyLnBhZ2VYIC0gb2Zmc2V0LmxlZnQgLSB4KSAvIHdpZHRoKTtcbiAgICAgICAgaW1hZ2VEYXRhLnkgLT0gb2Zmc2V0SGVpZ2h0ICogKChjZW50ZXIucGFnZVkgLSBvZmZzZXQudG9wIC0geSkgLyBoZWlnaHQpO1xuICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHBpdm90KSAmJiBpc051bWJlcihwaXZvdC54KSAmJiBpc051bWJlcihwaXZvdC55KSkge1xuICAgICAgICBpbWFnZURhdGEueCAtPSBvZmZzZXRXaWR0aCAqICgocGl2b3QueCAtIHgpIC8gd2lkdGgpO1xuICAgICAgICBpbWFnZURhdGEueSAtPSBvZmZzZXRIZWlnaHQgKiAoKHBpdm90LnkgLSB5KSAvIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBab29tIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgaW1hZ2VcbiAgICAgICAgaW1hZ2VEYXRhLnggLT0gb2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICBpbWFnZURhdGEueSAtPSBvZmZzZXRIZWlnaHQgLyAyO1xuICAgICAgfVxuICAgICAgaW1hZ2VEYXRhLmxlZnQgPSBpbWFnZURhdGEueDtcbiAgICAgIGltYWdlRGF0YS50b3AgPSBpbWFnZURhdGEueTtcbiAgICAgIGltYWdlRGF0YS53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgaW1hZ2VEYXRhLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIGltYWdlRGF0YS5vbGRSYXRpbyA9IG9sZFJhdGlvO1xuICAgICAgaW1hZ2VEYXRhLnJhdGlvID0gcmF0aW87XG4gICAgICB0aGlzLnJlbmRlckltYWdlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM2Lnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy56b29tZWQpKSB7XG4gICAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfWk9PTUVELCBvcHRpb25zLnpvb21lZCwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfWk9PTUVELCB7XG4gICAgICAgICAgcmF0aW86IHJhdGlvLFxuICAgICAgICAgIG9sZFJhdGlvOiBvbGRSYXRpbyxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBfb3JpZ2luYWxFdmVudFxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChzaG93VG9vbHRpcCkge1xuICAgICAgICB0aGlzLnRvb2x0aXAoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBQbGF5IHRoZSBpbWFnZXNcbiAgICogQHBhcmFtIHtib29sZWFufEZ1bGxzY3JlZW5PcHRpb25zfSBbZnVsbHNjcmVlbj1mYWxzZV0gLSBJbmRpY2F0ZSBpZiByZXF1ZXN0IGZ1bGxzY3JlZW4gb3Igbm90LlxuICAgKiBAcmV0dXJucyB7Vmlld2VyfSB0aGlzXG4gICAqL1xuICBwbGF5OiBmdW5jdGlvbiBwbGF5KCkge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgIHZhciBmdWxsc2NyZWVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICBpZiAoIXRoaXMuaXNTaG93biB8fCB0aGlzLnBsYXllZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnBsYXkpKSB7XG4gICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9QTEFZLCBvcHRpb25zLnBsYXksIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIEVWRU5UX1BMQVkpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllcjtcbiAgICB2YXIgb25Mb2FkID0gdGhpcy5sb2FkSW1hZ2UuYmluZCh0aGlzKTtcbiAgICB2YXIgbGlzdCA9IFtdO1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB0aGlzLnBsYXllZCA9IHRydWU7XG4gICAgdGhpcy5vbkxvYWRXaGVuUGxheSA9IG9uTG9hZDtcbiAgICBpZiAoZnVsbHNjcmVlbikge1xuICAgICAgdGhpcy5yZXF1ZXN0RnVsbHNjcmVlbihmdWxsc2NyZWVuKTtcbiAgICB9XG4gICAgYWRkQ2xhc3MocGxheWVyLCBDTEFTU19TSE9XKTtcbiAgICBmb3JFYWNoKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICB2YXIgaW1nID0gaXRlbS5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcbiAgICAgIHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgaW1hZ2Uuc3JjID0gZ2V0RGF0YShpbWcsICdvcmlnaW5hbFVybCcpO1xuICAgICAgaW1hZ2UuYWx0ID0gaW1nLmdldEF0dHJpYnV0ZSgnYWx0Jyk7XG4gICAgICBpbWFnZS5yZWZlcnJlclBvbGljeSA9IGltZy5yZWZlcnJlclBvbGljeTtcbiAgICAgIHRvdGFsICs9IDE7XG4gICAgICBhZGRDbGFzcyhpbWFnZSwgQ0xBU1NfRkFERSk7XG4gICAgICB0b2dnbGVDbGFzcyhpbWFnZSwgQ0xBU1NfVFJBTlNJVElPTiwgb3B0aW9ucy50cmFuc2l0aW9uKTtcbiAgICAgIGlmIChoYXNDbGFzcyhpdGVtLCBDTEFTU19BQ1RJVkUpKSB7XG4gICAgICAgIGFkZENsYXNzKGltYWdlLCBDTEFTU19JTik7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGxpc3QucHVzaChpbWFnZSk7XG4gICAgICBhZGRMaXN0ZW5lcihpbWFnZSwgRVZFTlRfTE9BRCwgb25Mb2FkLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcGxheWVyLmFwcGVuZENoaWxkKGltYWdlKTtcbiAgICB9KTtcbiAgICBpZiAoaXNOdW1iZXIob3B0aW9ucy5pbnRlcnZhbCkgJiYgb3B0aW9ucy5pbnRlcnZhbCA+IDApIHtcbiAgICAgIHZhciBwcmV2ID0gZnVuY3Rpb24gcHJldigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzNy5wbGF5aW5nLnRpbWVvdXQpO1xuICAgICAgICByZW1vdmVDbGFzcyhsaXN0W2luZGV4XSwgQ0xBU1NfSU4pO1xuICAgICAgICBpbmRleCAtPSAxO1xuICAgICAgICBpbmRleCA9IGluZGV4ID49IDAgPyBpbmRleCA6IHRvdGFsIC0gMTtcbiAgICAgICAgYWRkQ2xhc3MobGlzdFtpbmRleF0sIENMQVNTX0lOKTtcbiAgICAgICAgX3RoaXM3LnBsYXlpbmcudGltZW91dCA9IHNldFRpbWVvdXQocHJldiwgb3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgICB9O1xuICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXM3LnBsYXlpbmcudGltZW91dCk7XG4gICAgICAgIHJlbW92ZUNsYXNzKGxpc3RbaW5kZXhdLCBDTEFTU19JTik7XG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgIGluZGV4ID0gaW5kZXggPCB0b3RhbCA/IGluZGV4IDogMDtcbiAgICAgICAgYWRkQ2xhc3MobGlzdFtpbmRleF0sIENMQVNTX0lOKTtcbiAgICAgICAgX3RoaXM3LnBsYXlpbmcudGltZW91dCA9IHNldFRpbWVvdXQobmV4dCwgb3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgICB9O1xuICAgICAgaWYgKHRvdGFsID4gMSkge1xuICAgICAgICB0aGlzLnBsYXlpbmcgPSB7XG4gICAgICAgICAgcHJldjogcHJldixcbiAgICAgICAgICBuZXh0OiBuZXh0LFxuICAgICAgICAgIHRpbWVvdXQ6IHNldFRpbWVvdXQobmV4dCwgb3B0aW9ucy5pbnRlcnZhbClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIFN0b3AgcGxheVxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHZhciBfdGhpczggPSB0aGlzO1xuICAgIGlmICghdGhpcy5wbGF5ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5zdG9wKSkge1xuICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfU1RPUCwgb3B0aW9ucy5zdG9wLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2hFdmVudChlbGVtZW50LCBFVkVOVF9TVE9QKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgcGxheWVyID0gdGhpcy5wbGF5ZXI7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGxheWluZy50aW1lb3V0KTtcbiAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBsYXllZCA9IGZhbHNlO1xuICAgIGZvckVhY2gocGxheWVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKSwgZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihpbWFnZSwgRVZFTlRfTE9BRCwgX3RoaXM4Lm9uTG9hZFdoZW5QbGF5KTtcbiAgICB9KTtcbiAgICByZW1vdmVDbGFzcyhwbGF5ZXIsIENMQVNTX1NIT1cpO1xuICAgIHBsYXllci5pbm5lckhUTUwgPSAnJztcbiAgICB0aGlzLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIEVudGVyIG1vZGFsIG1vZGUgKG9ubHkgYXZhaWxhYmxlIGluIGlubGluZSBtb2RlKVxuICBmdWxsOiBmdW5jdGlvbiBmdWxsKCkge1xuICAgIHZhciBfdGhpczkgPSB0aGlzO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgdmlld2VyID0gdGhpcy52aWV3ZXIsXG4gICAgICBpbWFnZSA9IHRoaXMuaW1hZ2UsXG4gICAgICBsaXN0ID0gdGhpcy5saXN0O1xuICAgIGlmICghdGhpcy5pc1Nob3duIHx8IHRoaXMucGxheWVkIHx8IHRoaXMuZnVsbGVkIHx8ICFvcHRpb25zLmlubGluZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuZnVsbGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wZW4oKTtcbiAgICBhZGRDbGFzcyh0aGlzLmJ1dHRvbiwgQ0xBU1NfRlVMTFNDUkVFTl9FWElUKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uKSB7XG4gICAgICByZW1vdmVDbGFzcyhsaXN0LCBDTEFTU19UUkFOU0lUSU9OKTtcbiAgICAgIGlmICh0aGlzLnZpZXdlZCkge1xuICAgICAgICByZW1vdmVDbGFzcyhpbWFnZSwgQ0xBU1NfVFJBTlNJVElPTik7XG4gICAgICB9XG4gICAgfVxuICAgIGFkZENsYXNzKHZpZXdlciwgQ0xBU1NfRklYRUQpO1xuICAgIHZpZXdlci5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XG4gICAgdmlld2VyLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5JywgdGhpcy50aXRsZS5pZCk7XG4gICAgdmlld2VyLnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsIHRydWUpO1xuICAgIHZpZXdlci5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgc2V0U3R5bGUodmlld2VyLCB7XG4gICAgICB6SW5kZXg6IG9wdGlvbnMuekluZGV4XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMuZm9jdXMpIHtcbiAgICAgIHRoaXMuZW5mb3JjZUZvY3VzKCk7XG4gICAgfVxuICAgIHRoaXMuaW5pdENvbnRhaW5lcigpO1xuICAgIHRoaXMudmlld2VyRGF0YSA9IGFzc2lnbih7fSwgdGhpcy5jb250YWluZXJEYXRhKTtcbiAgICB0aGlzLnJlbmRlckxpc3QoKTtcbiAgICBpZiAodGhpcy52aWV3ZWQpIHtcbiAgICAgIHRoaXMuaW5pdEltYWdlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM5LnJlbmRlckltYWdlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgYWRkQ2xhc3MoaW1hZ2UsIENMQVNTX1RSQU5TSVRJT04pO1xuICAgICAgICAgICAgICBhZGRDbGFzcyhsaXN0LCBDTEFTU19UUkFOU0lUSU9OKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIEV4aXQgbW9kYWwgbW9kZSAob25seSBhdmFpbGFibGUgaW4gaW5saW5lIG1vZGUpXG4gIGV4aXQ6IGZ1bmN0aW9uIGV4aXQoKSB7XG4gICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgdmlld2VyID0gdGhpcy52aWV3ZXIsXG4gICAgICBpbWFnZSA9IHRoaXMuaW1hZ2UsXG4gICAgICBsaXN0ID0gdGhpcy5saXN0O1xuICAgIGlmICghdGhpcy5pc1Nob3duIHx8IHRoaXMucGxheWVkIHx8ICF0aGlzLmZ1bGxlZCB8fCAhb3B0aW9ucy5pbmxpbmUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLmZ1bGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmJ1dHRvbiwgQ0xBU1NfRlVMTFNDUkVFTl9FWElUKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uKSB7XG4gICAgICByZW1vdmVDbGFzcyhsaXN0LCBDTEFTU19UUkFOU0lUSU9OKTtcbiAgICAgIGlmICh0aGlzLnZpZXdlZCkge1xuICAgICAgICByZW1vdmVDbGFzcyhpbWFnZSwgQ0xBU1NfVFJBTlNJVElPTik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZvY3VzKSB7XG4gICAgICB0aGlzLmNsZWFyRW5mb3JjZUZvY3VzKCk7XG4gICAgfVxuICAgIHZpZXdlci5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICB2aWV3ZXIucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknKTtcbiAgICB2aWV3ZXIucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJyk7XG4gICAgcmVtb3ZlQ2xhc3Modmlld2VyLCBDTEFTU19GSVhFRCk7XG4gICAgc2V0U3R5bGUodmlld2VyLCB7XG4gICAgICB6SW5kZXg6IG9wdGlvbnMuekluZGV4SW5saW5lXG4gICAgfSk7XG4gICAgdGhpcy52aWV3ZXJEYXRhID0gYXNzaWduKHt9LCB0aGlzLnBhcmVudERhdGEpO1xuICAgIHRoaXMucmVuZGVyVmlld2VyKCk7XG4gICAgdGhpcy5yZW5kZXJMaXN0KCk7XG4gICAgaWYgKHRoaXMudmlld2VkKSB7XG4gICAgICB0aGlzLmluaXRJbWFnZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMTAucmVuZGVySW1hZ2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBhZGRDbGFzcyhpbWFnZSwgQ0xBU1NfVFJBTlNJVElPTik7XG4gICAgICAgICAgICAgIGFkZENsYXNzKGxpc3QsIENMQVNTX1RSQU5TSVRJT04pO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gU2hvdyB0aGUgY3VycmVudCByYXRpbyBvZiB0aGUgaW1hZ2Ugd2l0aCBwZXJjZW50YWdlXG4gIHRvb2x0aXA6IGZ1bmN0aW9uIHRvb2x0aXAoKSB7XG4gICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgdG9vbHRpcEJveCA9IHRoaXMudG9vbHRpcEJveCxcbiAgICAgIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhO1xuICAgIGlmICghdGhpcy52aWV3ZWQgfHwgdGhpcy5wbGF5ZWQgfHwgIW9wdGlvbnMudG9vbHRpcCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvb2x0aXBCb3gudGV4dENvbnRlbnQgPSBcIlwiLmNvbmNhdChNYXRoLnJvdW5kKGltYWdlRGF0YS5yYXRpbyAqIDEwMCksIFwiJVwiKTtcbiAgICBpZiAoIXRoaXMudG9vbHRpcHBpbmcpIHtcbiAgICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuZmFkaW5nKSB7XG4gICAgICAgICAgZGlzcGF0Y2hFdmVudCh0b29sdGlwQm94LCBFVkVOVF9UUkFOU0lUSU9OX0VORCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkQ2xhc3ModG9vbHRpcEJveCwgQ0xBU1NfU0hPVyk7XG4gICAgICAgIGFkZENsYXNzKHRvb2x0aXBCb3gsIENMQVNTX0ZBREUpO1xuICAgICAgICBhZGRDbGFzcyh0b29sdGlwQm94LCBDTEFTU19UUkFOU0lUSU9OKTtcbiAgICAgICAgdG9vbHRpcEJveC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG5cbiAgICAgICAgLy8gRm9yY2UgcmVmbG93IHRvIGVuYWJsZSBDU1MzIHRyYW5zaXRpb25cbiAgICAgICAgdG9vbHRpcEJveC5pbml0aWFsT2Zmc2V0V2lkdGggPSB0b29sdGlwQm94Lm9mZnNldFdpZHRoO1xuICAgICAgICBhZGRDbGFzcyh0b29sdGlwQm94LCBDTEFTU19JTik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRDbGFzcyh0b29sdGlwQm94LCBDTEFTU19TSE9XKTtcbiAgICAgICAgdG9vbHRpcEJveC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRvb2x0aXBwaW5nKTtcbiAgICB9XG4gICAgdGhpcy50b29sdGlwcGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbikge1xuICAgICAgICBhZGRMaXN0ZW5lcih0b29sdGlwQm94LCBFVkVOVF9UUkFOU0lUSU9OX0VORCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRvb2x0aXBCb3gsIENMQVNTX1NIT1cpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRvb2x0aXBCb3gsIENMQVNTX0ZBREUpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRvb2x0aXBCb3gsIENMQVNTX1RSQU5TSVRJT04pO1xuICAgICAgICAgIHRvb2x0aXBCb3guc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgICAgIF90aGlzMTEuZmFkaW5nID0gZmFsc2U7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdmVDbGFzcyh0b29sdGlwQm94LCBDTEFTU19JTik7XG4gICAgICAgIF90aGlzMTEuZmFkaW5nID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKHRvb2x0aXBCb3gsIENMQVNTX1NIT1cpO1xuICAgICAgICB0b29sdGlwQm94LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIF90aGlzMTEudG9vbHRpcHBpbmcgPSBmYWxzZTtcbiAgICB9LCAxMDAwKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgaW1hZ2Ugc2l6ZSBiZXR3ZWVuIGl0cyBjdXJyZW50IHNpemUgYW5kIG5hdHVyYWwgc2l6ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBbX29yaWdpbmFsRXZlbnQ9bnVsbF0gLSBUaGUgb3JpZ2luYWwgZXZlbnQgaWYgYW55LlxuICAgKiBAcmV0dXJucyB7Vmlld2VyfSB0aGlzXG4gICAqL1xuICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICB2YXIgX29yaWdpbmFsRXZlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgaWYgKHRoaXMuaW1hZ2VEYXRhLnJhdGlvID09PSAxKSB7XG4gICAgICB0aGlzLnpvb21Ubyh0aGlzLmltYWdlRGF0YS5vbGRSYXRpbywgdHJ1ZSwgbnVsbCwgX29yaWdpbmFsRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnpvb21UbygxLCB0cnVlLCBudWxsLCBfb3JpZ2luYWxFdmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBSZXNldCB0aGUgaW1hZ2UgdG8gaXRzIGluaXRpYWwgc3RhdGVcbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnZpZXdlZCAmJiAhdGhpcy5wbGF5ZWQpIHtcbiAgICAgIHRoaXMuaW1hZ2VEYXRhID0gYXNzaWduKHt9LCB0aGlzLmluaXRpYWxJbWFnZURhdGEpO1xuICAgICAgdGhpcy5yZW5kZXJJbWFnZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gVXBkYXRlIHZpZXdlciB3aGVuIGltYWdlcyBjaGFuZ2VkXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBfdGhpczEyID0gdGhpcztcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBpc0ltZyA9IHRoaXMuaXNJbWc7XG5cbiAgICAvLyBEZXN0cm95IHZpZXdlciBpZiB0aGUgdGFyZ2V0IGltYWdlIHdhcyBkZWxldGVkXG4gICAgaWYgKGlzSW1nICYmICFlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdmFyIGltYWdlcyA9IFtdO1xuICAgIGZvckVhY2goaXNJbWcgPyBbZWxlbWVudF0gOiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZycpLCBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuZmlsdGVyKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXIuY2FsbChfdGhpczEyLCBpbWFnZSkpIHtcbiAgICAgICAgICBpbWFnZXMucHVzaChpbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMxMi5nZXRJbWFnZVVSTChpbWFnZSkpIHtcbiAgICAgICAgaW1hZ2VzLnB1c2goaW1hZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW1hZ2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuICAgIHRoaXMubGVuZ3RoID0gaW1hZ2VzLmxlbmd0aDtcbiAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgdmFyIGNoYW5nZWRJbmRleGVzID0gW107XG4gICAgICBmb3JFYWNoKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgIHZhciBpbWcgPSBpdGVtLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuICAgICAgICB2YXIgaW1hZ2UgPSBpbWFnZXNbaV07XG4gICAgICAgIGlmIChpbWFnZSAmJiBpbWcpIHtcbiAgICAgICAgICBpZiAoaW1hZ2Uuc3JjICE9PSBpbWcuc3JjXG5cbiAgICAgICAgICAvLyBUaXRsZSBjaGFuZ2VkICgjNDA4KVxuICAgICAgICAgIHx8IGltYWdlLmFsdCAhPT0gaW1nLmFsdCkge1xuICAgICAgICAgICAgY2hhbmdlZEluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhbmdlZEluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZXRTdHlsZSh0aGlzLmxpc3QsIHtcbiAgICAgICAgd2lkdGg6ICdhdXRvJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLmluaXRMaXN0KCk7XG4gICAgICBpZiAodGhpcy5pc1Nob3duKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCkge1xuICAgICAgICAgIGlmICh0aGlzLnZpZXdlZCkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZWRJbmRleCA9IGNoYW5nZWRJbmRleGVzLmluZGV4T2YodGhpcy5pbmRleCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgdGhpcy52aWV3ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy52aWV3KE1hdGgubWF4KE1hdGgubWluKHRoaXMuaW5kZXggLSBjaGFuZ2VkSW5kZXgsIHRoaXMubGVuZ3RoIC0gMSksIDApKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBhY3RpdmVJdGVtID0gdGhpcy5pdGVtc1t0aGlzLmluZGV4XTtcblxuICAgICAgICAgICAgICAvLyBSZWFjdGl2YXRlIHRoZSBjdXJyZW50IHZpZXdpbmcgaXRlbSBhZnRlciByZXNldCB0aGUgbGlzdC5cbiAgICAgICAgICAgICAgYWRkQ2xhc3MoYWN0aXZlSXRlbSwgQ0xBU1NfQUNUSVZFKTtcbiAgICAgICAgICAgICAgYWN0aXZlSXRlbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pbWFnZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy52aWV3ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICB0aGlzLmltYWdlRGF0YSA9IHt9O1xuICAgICAgICAgIHRoaXMuY2FudmFzLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgIHRoaXMudGl0bGUuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5idWlsZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gRGVzdHJveSB0aGUgdmlld2VyXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghZWxlbWVudFtOQU1FU1BBQ0VdKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICBpZiAodGhpcy5wbGF5ZWQpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5pbmxpbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuZnVsbGVkKSB7XG4gICAgICAgICAgdGhpcy5leGl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1Nob3duKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdpbmcpIHtcbiAgICAgICAgICBpZiAodGhpcy5pbWFnZVJlbmRlcmluZykge1xuICAgICAgICAgICAgdGhpcy5pbWFnZVJlbmRlcmluZy5hYm9ydCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbWFnZUluaXRpYWxpemluZykge1xuICAgICAgICAgICAgdGhpcy5pbWFnZUluaXRpYWxpemluZy5hYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oaWRpbmcpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25pbmcuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpZGRlbigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNob3dpbmcpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uaW5nLmFib3J0KCk7XG4gICAgICAgIHRoaXMuaGlkZGVuKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLnZpZXdlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudmlld2VyKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5saW5lKSB7XG4gICAgICBpZiAodGhpcy5kZWxheWluZykge1xuICAgICAgICB0aGlzLmRlbGF5aW5nLmFib3J0KCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW5pdGlhbGl6aW5nKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6aW5nLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5pbmxpbmUpIHtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NMSUNLLCB0aGlzLm9uU3RhcnQpO1xuICAgIH1cbiAgICBlbGVtZW50W05BTUVTUEFDRV0gPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbnZhciBvdGhlcnMgPSB7XG4gIGdldEltYWdlVVJMOiBmdW5jdGlvbiBnZXRJbWFnZVVSTChpbWFnZSkge1xuICAgIHZhciB1cmwgPSB0aGlzLm9wdGlvbnMudXJsO1xuICAgIGlmIChpc1N0cmluZyh1cmwpKSB7XG4gICAgICB1cmwgPSBpbWFnZS5nZXRBdHRyaWJ1dGUodXJsKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odXJsKSkge1xuICAgICAgdXJsID0gdXJsLmNhbGwodGhpcywgaW1hZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cmwgPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfSxcbiAgZW5mb3JjZUZvY3VzOiBmdW5jdGlvbiBlbmZvcmNlRm9jdXMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLmNsZWFyRW5mb3JjZUZvY3VzKCk7XG4gICAgYWRkTGlzdGVuZXIoZG9jdW1lbnQsIEVWRU5UX0ZPQ1VTSU4sIHRoaXMub25Gb2N1c2luID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgdmlld2VyID0gX3RoaXMudmlld2VyO1xuICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGlmICh0YXJnZXQgPT09IGRvY3VtZW50IHx8IHRhcmdldCA9PT0gdmlld2VyIHx8IHZpZXdlci5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlICh0YXJnZXQpIHtcbiAgICAgICAgLy8gQXZvaWQgY29uZmxpY3RzIHdpdGggb3RoZXIgbW9kYWxzICgjNDc0LCAjNTQwKVxuICAgICAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSAhPT0gbnVsbCB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJykgPT09ICd0cnVlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHZpZXdlci5mb2N1cygpO1xuICAgIH0pO1xuICB9LFxuICBjbGVhckVuZm9yY2VGb2N1czogZnVuY3Rpb24gY2xlYXJFbmZvcmNlRm9jdXMoKSB7XG4gICAgaWYgKHRoaXMub25Gb2N1c2luKSB7XG4gICAgICByZW1vdmVMaXN0ZW5lcihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiwgdGhpcy5vbkZvY3VzaW4pO1xuICAgICAgdGhpcy5vbkZvY3VzaW4gPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcbiAgICB2YXIgYm9keSA9IHRoaXMuYm9keTtcbiAgICBhZGRDbGFzcyhib2R5LCBDTEFTU19PUEVOKTtcbiAgICBpZiAodGhpcy5zY3JvbGxiYXJXaWR0aCA+IDApIHtcbiAgICAgIGJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCJcIi5jb25jYXQodGhpcy5zY3JvbGxiYXJXaWR0aCArIChwYXJzZUZsb2F0KHRoaXMuaW5pdGlhbEJvZHlDb21wdXRlZFBhZGRpbmdSaWdodCkgfHwgMCksIFwicHhcIik7XG4gICAgfVxuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgdmFyIGJvZHkgPSB0aGlzLmJvZHk7XG4gICAgcmVtb3ZlQ2xhc3MoYm9keSwgQ0xBU1NfT1BFTik7XG4gICAgaWYgKHRoaXMuc2Nyb2xsYmFyV2lkdGggPiAwKSB7XG4gICAgICBib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHRoaXMuaW5pdGlhbEJvZHlQYWRkaW5nUmlnaHQ7XG4gICAgfVxuICB9LFxuICBzaG93bjogZnVuY3Rpb24gc2hvd24oKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgdmlld2VyID0gdGhpcy52aWV3ZXI7XG4gICAgdGhpcy5mdWxsZWQgPSB0cnVlO1xuICAgIHRoaXMuaXNTaG93biA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgICB0aGlzLmJpbmQoKTtcbiAgICB0aGlzLnNob3dpbmcgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy5mb2N1cykge1xuICAgICAgdmlld2VyLmZvY3VzKCk7XG4gICAgICB0aGlzLmVuZm9yY2VGb2N1cygpO1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnNob3duKSkge1xuICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfU0hPV04sIG9wdGlvbnMuc2hvd24sIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIEVWRU5UX1NIT1dOKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVhZHkgJiYgdGhpcy5pc1Nob3duICYmICF0aGlzLmhpZGluZykge1xuICAgICAgdGhpcy52aWV3KHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgfSxcbiAgaGlkZGVuOiBmdW5jdGlvbiBoaWRkZW4oKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgdmlld2VyID0gdGhpcy52aWV3ZXI7XG4gICAgaWYgKG9wdGlvbnMuZnVjdXMpIHtcbiAgICAgIHRoaXMuY2xlYXJFbmZvcmNlRm9jdXMoKTtcbiAgICB9XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIHRoaXMudW5iaW5kKCk7XG4gICAgYWRkQ2xhc3Modmlld2VyLCBDTEFTU19ISURFKTtcbiAgICB2aWV3ZXIucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgdmlld2VyLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5Jyk7XG4gICAgdmlld2VyLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xuICAgIHZpZXdlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG4gICAgdGhpcy5yZXNldExpc3QoKTtcbiAgICB0aGlzLnJlc2V0SW1hZ2UoKTtcbiAgICB0aGlzLmZ1bGxlZCA9IGZhbHNlO1xuICAgIHRoaXMudmlld2VkID0gZmFsc2U7XG4gICAgdGhpcy5pc1Nob3duID0gZmFsc2U7XG4gICAgdGhpcy5oaWRpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmhpZGRlbikpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfSElEREVOLCBvcHRpb25zLmhpZGRlbiwge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNwYXRjaEV2ZW50KGVsZW1lbnQsIEVWRU5UX0hJRERFTiwgbnVsbCwge1xuICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICByZXF1ZXN0RnVsbHNjcmVlbjogZnVuY3Rpb24gcmVxdWVzdEZ1bGxzY3JlZW4ob3B0aW9ucykge1xuICAgIHZhciBkb2N1bWVudCA9IHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgIGlmICh0aGlzLmZ1bGxlZCAmJiAhKGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQpKSB7XG4gICAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAvLyBFbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKClcbiAgICAgIGlmIChkb2N1bWVudEVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgLy8gQXZvaWQgVHlwZUVycm9yIHdoZW4gY29udmVydCBgb3B0aW9uc2AgdG8gZGljdGlvbmFyeVxuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgIGRvY3VtZW50RWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbihvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb2N1bWVudEVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgZG9jdW1lbnRFbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKEVsZW1lbnQuQUxMT1dfS0VZQk9BUkRfSU5QVVQpO1xuICAgICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4pIHtcbiAgICAgICAgZG9jdW1lbnRFbGVtZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuKCk7XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudC5tc1JlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgIGRvY3VtZW50RWxlbWVudC5tc1JlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBleGl0RnVsbHNjcmVlbjogZnVuY3Rpb24gZXhpdEZ1bGxzY3JlZW4oKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgaWYgKHRoaXMuZnVsbGVkICYmIChkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50KSkge1xuICAgICAgLy8gRG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKVxuICAgICAgaWYgKGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKSB7XG4gICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKSB7XG4gICAgICAgIGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4pIHtcbiAgICAgICAgZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbigpO1xuICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKSB7XG4gICAgICAgIGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNoYW5nZTogZnVuY3Rpb24gY2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBwb2ludGVycyA9IHRoaXMucG9pbnRlcnM7XG4gICAgdmFyIHBvaW50ZXIgPSBwb2ludGVyc1tPYmplY3Qua2V5cyhwb2ludGVycylbMF1dO1xuXG4gICAgLy8gSW4gdGhlIGNhc2Ugb2YgdGhlIGBwb2ludGVyc2Agb2JqZWN0IGlzIGVtcHR5ICgjNDIxKVxuICAgIGlmICghcG9pbnRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0WCA9IHBvaW50ZXIuZW5kWCAtIHBvaW50ZXIuc3RhcnRYO1xuICAgIHZhciBvZmZzZXRZID0gcG9pbnRlci5lbmRZIC0gcG9pbnRlci5zdGFydFk7XG4gICAgc3dpdGNoICh0aGlzLmFjdGlvbikge1xuICAgICAgLy8gTW92ZSB0aGUgY3VycmVudCBpbWFnZVxuICAgICAgY2FzZSBBQ1RJT05fTU9WRTpcbiAgICAgICAgaWYgKG9mZnNldFggIT09IDAgfHwgb2Zmc2V0WSAhPT0gMCkge1xuICAgICAgICAgIHRoaXMucG9pbnRlck1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLm1vdmUob2Zmc2V0WCwgb2Zmc2V0WSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBab29tIHRoZSBjdXJyZW50IGltYWdlXG4gICAgICBjYXNlIEFDVElPTl9aT09NOlxuICAgICAgICB0aGlzLnpvb20oZ2V0TWF4Wm9vbVJhdGlvKHBvaW50ZXJzKSwgZmFsc2UsIG51bGwsIGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFDVElPTl9TV0lUQ0g6XG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLmFjdGlvbiA9ICdzd2l0Y2hlZCc7XG4gICAgICAgICAgdmFyIGFic29sdXRlT2Zmc2V0WCA9IE1hdGguYWJzKG9mZnNldFgpO1xuICAgICAgICAgIGlmIChhYnNvbHV0ZU9mZnNldFggPiAxICYmIGFic29sdXRlT2Zmc2V0WCA+IE1hdGguYWJzKG9mZnNldFkpKSB7XG4gICAgICAgICAgICAvLyBFbXB0eSBgcG9pbnRlcnNgIGFzIGB0b3VjaGVuZGAgZXZlbnQgd2lsbCBub3QgYmUgZmlyZWQgYWZ0ZXIgc3dpcGVkIGluIGlPUyBicm93c2Vycy5cbiAgICAgICAgICAgIHRoaXMucG9pbnRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChvZmZzZXRYID4gMSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXYob3B0aW9ucy5sb29wKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0WCA8IC0xKSB7XG4gICAgICAgICAgICAgIHRoaXMubmV4dChvcHRpb25zLmxvb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlXG4gICAgZm9yRWFjaChwb2ludGVycywgZnVuY3Rpb24gKHApIHtcbiAgICAgIHAuc3RhcnRYID0gcC5lbmRYO1xuICAgICAgcC5zdGFydFkgPSBwLmVuZFk7XG4gICAgfSk7XG4gIH0sXG4gIGlzU3dpdGNoYWJsZTogZnVuY3Rpb24gaXNTd2l0Y2hhYmxlKCkge1xuICAgIHZhciBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YSxcbiAgICAgIHZpZXdlckRhdGEgPSB0aGlzLnZpZXdlckRhdGE7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gMSAmJiBpbWFnZURhdGEueCA+PSAwICYmIGltYWdlRGF0YS55ID49IDAgJiYgaW1hZ2VEYXRhLndpZHRoIDw9IHZpZXdlckRhdGEud2lkdGggJiYgaW1hZ2VEYXRhLmhlaWdodCA8PSB2aWV3ZXJEYXRhLmhlaWdodDtcbiAgfVxufTtcblxudmFyIEFub3RoZXJWaWV3ZXIgPSBXSU5ET1cuVmlld2VyO1xudmFyIGdldFVuaXF1ZUlEID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWQgKz0gMTtcbiAgICByZXR1cm4gaWQ7XG4gIH07XG59KC0xKTtcbnZhciBWaWV3ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFZpZXdlci5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50IGZvciB2aWV3aW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFZpZXdlcihlbGVtZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3ZXIpO1xuICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmaXJzdCBhcmd1bWVudCBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhbiBlbGVtZW50LicpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgREVGQVVMVFMsIGlzUGxhaW5PYmplY3Qob3B0aW9ucykgJiYgb3B0aW9ucyk7XG4gICAgdGhpcy5hY3Rpb24gPSBmYWxzZTtcbiAgICB0aGlzLmZhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZnVsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5oaWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmltYWdlQ2xpY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW1hZ2VEYXRhID0ge307XG4gICAgdGhpcy5pbmRleCA9IHRoaXMub3B0aW9ucy5pbml0aWFsVmlld0luZGV4O1xuICAgIHRoaXMuaXNJbWcgPSBmYWxzZTtcbiAgICB0aGlzLmlzU2hvd24gPSBmYWxzZTtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5tb3ZpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBsYXllZCA9IGZhbHNlO1xuICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMucG9pbnRlcnMgPSB7fTtcbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5yb3RhdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuc2NhbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuc2hvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMudGltZW91dCA9IGZhbHNlO1xuICAgIHRoaXMudG9vbHRpcHBpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnZpZXdlZCA9IGZhbHNlO1xuICAgIHRoaXMudmlld2luZyA9IGZhbHNlO1xuICAgIHRoaXMud2hlZWxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBvaW50ZXJNb3ZlZCA9IGZhbHNlO1xuICAgIHRoaXMuaWQgPSBnZXRVbmlxdWVJRCgpO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhWaWV3ZXIsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChlbGVtZW50W05BTUVTUEFDRV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxlbWVudFtOQU1FU1BBQ0VdID0gdGhpcztcblxuICAgICAgLy8gVGhlIGBmb2N1c2Agb3B0aW9uIHJlcXVpcmVzIHRoZSBga2V5Ym9hcmRgIG9wdGlvbiBzZXQgdG8gYHRydWVgLlxuICAgICAgaWYgKG9wdGlvbnMuZm9jdXMgJiYgIW9wdGlvbnMua2V5Ym9hcmQpIHtcbiAgICAgICAgb3B0aW9ucy5mb2N1cyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGlzSW1nID0gZWxlbWVudC5sb2NhbE5hbWUgPT09ICdpbWcnO1xuICAgICAgdmFyIGltYWdlcyA9IFtdO1xuICAgICAgZm9yRWFjaChpc0ltZyA/IFtlbGVtZW50XSA6IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW1nJyksIGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmZpbHRlcikpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXIuY2FsbChfdGhpcywgaW1hZ2UpKSB7XG4gICAgICAgICAgICBpbWFnZXMucHVzaChpbWFnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF90aGlzLmdldEltYWdlVVJMKGltYWdlKSkge1xuICAgICAgICAgIGltYWdlcy5wdXNoKGltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmlzSW1nID0gaXNJbWc7XG4gICAgICB0aGlzLmxlbmd0aCA9IGltYWdlcy5sZW5ndGg7XG4gICAgICB0aGlzLmltYWdlcyA9IGltYWdlcztcbiAgICAgIHRoaXMuaW5pdEJvZHkoKTtcblxuICAgICAgLy8gT3ZlcnJpZGUgYHRyYW5zaXRpb25gIG9wdGlvbiBpZiBpdCBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICBpZiAoaXNVbmRlZmluZWQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChOQU1FU1BBQ0UpLnN0eWxlLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNpdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuaW5saW5lKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IGZ1bmN0aW9uIHByb2dyZXNzKCkge1xuICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgaWYgKGNvdW50ID09PSBfdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0O1xuICAgICAgICAgICAgX3RoaXMuaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5kZWxheWluZyA9IHtcbiAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gYnVpbGQgYXN5bmNocm9ub3VzbHkgdG8ga2VlcCBgdGhpcy52aWV3ZXJgIGlzIGFjY2Vzc2libGUgaW4gYHJlYWR5YCBldmVudCBoYW5kbGVyLlxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpcy5kZWxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICBfdGhpcy5idWlsZCgpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemluZyA9IHtcbiAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgICAgICBmb3JFYWNoKGltYWdlcywgZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgICAgICAgIGlmICghaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihpbWFnZSwgRVZFTlRfTE9BRCwgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGltYWdlLCBFVkVOVF9FUlJPUiwgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvckVhY2goaW1hZ2VzLCBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgICBpZiAoaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgIHByb2dyZXNzKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvbkxvYWQ7XG4gICAgICAgICAgICB2YXIgb25FcnJvcjtcbiAgICAgICAgICAgIGFkZExpc3RlbmVyKGltYWdlLCBFVkVOVF9MT0FELCBvbkxvYWQgPSBmdW5jdGlvbiBvbkxvYWQoKSB7XG4gICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGltYWdlLCBFVkVOVF9FUlJPUiwgb25FcnJvcik7XG4gICAgICAgICAgICAgIHByb2dyZXNzKCk7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWRkTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0VSUk9SLCBvbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcigpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoaW1hZ2UsIEVWRU5UX0xPQUQsIG9uTG9hZCk7XG4gICAgICAgICAgICAgIHByb2dyZXNzKCk7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DTElDSywgdGhpcy5vblN0YXJ0ID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gX3JlZi50YXJnZXQ7XG4gICAgICAgICAgaWYgKHRhcmdldC5sb2NhbE5hbWUgPT09ICdpbWcnICYmICghaXNGdW5jdGlvbihvcHRpb25zLmZpbHRlcikgfHwgb3B0aW9ucy5maWx0ZXIuY2FsbChfdGhpcywgdGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIF90aGlzLnZpZXcoX3RoaXMuaW1hZ2VzLmluZGV4T2YodGFyZ2V0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IFRFTVBMQVRFO1xuICAgICAgdmFyIHZpZXdlciA9IHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItY29udGFpbmVyXCIpKTtcbiAgICAgIHZhciB0aXRsZSA9IHZpZXdlci5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLXRpdGxlXCIpKTtcbiAgICAgIHZhciB0b29sYmFyID0gdmlld2VyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItdG9vbGJhclwiKSk7XG4gICAgICB2YXIgbmF2YmFyID0gdmlld2VyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItbmF2YmFyXCIpKTtcbiAgICAgIHZhciBidXR0b24gPSB2aWV3ZXIucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1idXR0b25cIikpO1xuICAgICAgdmFyIGNhbnZhcyA9IHZpZXdlci5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWNhbnZhc1wiKSk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHRoaXMudmlld2VyID0gdmlld2VyO1xuICAgICAgdGhpcy50aXRsZSA9IHRpdGxlO1xuICAgICAgdGhpcy50b29sYmFyID0gdG9vbGJhcjtcbiAgICAgIHRoaXMubmF2YmFyID0gbmF2YmFyO1xuICAgICAgdGhpcy5idXR0b24gPSBidXR0b247XG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMuZm9vdGVyID0gdmlld2VyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItZm9vdGVyXCIpKTtcbiAgICAgIHRoaXMudG9vbHRpcEJveCA9IHZpZXdlci5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLXRvb2x0aXBcIikpO1xuICAgICAgdGhpcy5wbGF5ZXIgPSB2aWV3ZXIucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1wbGF5ZXJcIikpO1xuICAgICAgdGhpcy5saXN0ID0gdmlld2VyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItbGlzdFwiKSk7XG4gICAgICB2aWV3ZXIuaWQgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UpLmNvbmNhdCh0aGlzLmlkKTtcbiAgICAgIHRpdGxlLmlkID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIlRpdGxlXCIpLmNvbmNhdCh0aGlzLmlkKTtcbiAgICAgIGFkZENsYXNzKHRpdGxlLCAhb3B0aW9ucy50aXRsZSA/IENMQVNTX0hJREUgOiBnZXRSZXNwb25zaXZlQ2xhc3MoQXJyYXkuaXNBcnJheShvcHRpb25zLnRpdGxlKSA/IG9wdGlvbnMudGl0bGVbMF0gOiBvcHRpb25zLnRpdGxlKSk7XG4gICAgICBhZGRDbGFzcyhuYXZiYXIsICFvcHRpb25zLm5hdmJhciA/IENMQVNTX0hJREUgOiBnZXRSZXNwb25zaXZlQ2xhc3Mob3B0aW9ucy5uYXZiYXIpKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGJ1dHRvbiwgQ0xBU1NfSElERSwgIW9wdGlvbnMuYnV0dG9uKTtcbiAgICAgIGlmIChvcHRpb25zLmtleWJvYXJkKSB7XG4gICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5iYWNrZHJvcCkge1xuICAgICAgICBhZGRDbGFzcyh2aWV3ZXIsIFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItYmFja2Ryb3BcIikpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuaW5saW5lICYmIG9wdGlvbnMuYmFja2Ryb3AgIT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgc2V0RGF0YShjYW52YXMsIERBVEFfQUNUSU9OLCAnaGlkZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNTdHJpbmcob3B0aW9ucy5jbGFzc05hbWUpICYmIG9wdGlvbnMuY2xhc3NOYW1lKSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlcmUgYXJlIG11bHRpcGxlIGNsYXNzIG5hbWVzXG4gICAgICAgIG9wdGlvbnMuY2xhc3NOYW1lLnNwbGl0KFJFR0VYUF9TUEFDRVMpLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICAgIGFkZENsYXNzKHZpZXdlciwgY2xhc3NOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy50b29sYmFyKSB7XG4gICAgICAgIHZhciBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgdmFyIGN1c3RvbSA9IGlzUGxhaW5PYmplY3Qob3B0aW9ucy50b29sYmFyKTtcbiAgICAgICAgdmFyIHpvb21CdXR0b25zID0gQlVUVE9OUy5zbGljZSgwLCAzKTtcbiAgICAgICAgdmFyIHJvdGF0ZUJ1dHRvbnMgPSBCVVRUT05TLnNsaWNlKDcsIDkpO1xuICAgICAgICB2YXIgc2NhbGVCdXR0b25zID0gQlVUVE9OUy5zbGljZSg5KTtcbiAgICAgICAgaWYgKCFjdXN0b20pIHtcbiAgICAgICAgICBhZGRDbGFzcyh0b29sYmFyLCBnZXRSZXNwb25zaXZlQ2xhc3Mob3B0aW9ucy50b29sYmFyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yRWFjaChjdXN0b20gPyBvcHRpb25zLnRvb2xiYXIgOiBCVVRUT05TLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGRlZXAgPSBjdXN0b20gJiYgaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBjdXN0b20gPyBoeXBoZW5hdGUoaW5kZXgpIDogdmFsdWU7XG4gICAgICAgICAgdmFyIHNob3cgPSBkZWVwICYmICFpc1VuZGVmaW5lZCh2YWx1ZS5zaG93KSA/IHZhbHVlLnNob3cgOiB2YWx1ZTtcbiAgICAgICAgICBpZiAoIXNob3cgfHwgIW9wdGlvbnMuem9vbWFibGUgJiYgem9vbUJ1dHRvbnMuaW5kZXhPZihuYW1lKSAhPT0gLTEgfHwgIW9wdGlvbnMucm90YXRhYmxlICYmIHJvdGF0ZUJ1dHRvbnMuaW5kZXhPZihuYW1lKSAhPT0gLTEgfHwgIW9wdGlvbnMuc2NhbGFibGUgJiYgc2NhbGVCdXR0b25zLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzaXplID0gZGVlcCAmJiAhaXNVbmRlZmluZWQodmFsdWUuc2l6ZSkgPyB2YWx1ZS5zaXplIDogdmFsdWU7XG4gICAgICAgICAgdmFyIGNsaWNrID0gZGVlcCAmJiAhaXNVbmRlZmluZWQodmFsdWUuY2xpY2spID8gdmFsdWUuY2xpY2sgOiB2YWx1ZTtcbiAgICAgICAgICB2YXIgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcbiAgICAgICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcbiAgICAgICAgICBhZGRDbGFzcyhpdGVtLCBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLVwiKS5jb25jYXQobmFtZSkpO1xuICAgICAgICAgIGlmICghaXNGdW5jdGlvbihjbGljaykpIHtcbiAgICAgICAgICAgIHNldERhdGEoaXRlbSwgREFUQV9BQ1RJT04sIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNOdW1iZXIoc2hvdykpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGl0ZW0sIGdldFJlc3BvbnNpdmVDbGFzcyhzaG93KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChbJ3NtYWxsJywgJ2xhcmdlJ10uaW5kZXhPZihzaXplKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGl0ZW0sIFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItXCIpLmNvbmNhdChzaXplKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAncGxheScpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGl0ZW0sIFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItbGFyZ2VcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjbGljaykpIHtcbiAgICAgICAgICAgIGFkZExpc3RlbmVyKGl0ZW0sIEVWRU5UX0NMSUNLLCBjbGljayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpc3QuYXBwZW5kQ2hpbGQoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0b29sYmFyLmFwcGVuZENoaWxkKGxpc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkQ2xhc3ModG9vbGJhciwgQ0xBU1NfSElERSk7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMucm90YXRhYmxlKSB7XG4gICAgICAgIHZhciByb3RhdGVzID0gdG9vbGJhci5xdWVyeVNlbGVjdG9yQWxsKCdsaVtjbGFzcyo9XCJyb3RhdGVcIl0nKTtcbiAgICAgICAgYWRkQ2xhc3Mocm90YXRlcywgQ0xBU1NfSU5WSVNJQkxFKTtcbiAgICAgICAgZm9yRWFjaChyb3RhdGVzLCBmdW5jdGlvbiAocm90YXRlKSB7XG4gICAgICAgICAgdG9vbGJhci5hcHBlbmRDaGlsZChyb3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmlubGluZSkge1xuICAgICAgICBhZGRDbGFzcyhidXR0b24sIENMQVNTX0ZVTExTQ1JFRU4pO1xuICAgICAgICBzZXRTdHlsZSh2aWV3ZXIsIHtcbiAgICAgICAgICB6SW5kZXg6IG9wdGlvbnMuekluZGV4SW5saW5lXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICBzZXRTdHlsZShwYXJlbnQsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh2aWV3ZXIsIGVsZW1lbnQubmV4dFNpYmxpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkQ2xhc3MoYnV0dG9uLCBDTEFTU19DTE9TRSk7XG4gICAgICAgIGFkZENsYXNzKHZpZXdlciwgQ0xBU1NfRklYRUQpO1xuICAgICAgICBhZGRDbGFzcyh2aWV3ZXIsIENMQVNTX0ZBREUpO1xuICAgICAgICBhZGRDbGFzcyh2aWV3ZXIsIENMQVNTX0hJREUpO1xuICAgICAgICBzZXRTdHlsZSh2aWV3ZXIsIHtcbiAgICAgICAgICB6SW5kZXg6IG9wdGlvbnMuekluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgIGlmIChpc1N0cmluZyhjb250YWluZXIpKSB7XG4gICAgICAgICAgY29udGFpbmVyID0gZWxlbWVudC5vd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuYm9keTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodmlld2VyKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmlubGluZSkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB0aGlzLmJpbmQoKTtcbiAgICAgICAgdGhpcy5pc1Nob3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5yZWFkeSkpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfUkVBRFksIG9wdGlvbnMucmVhZHksIHtcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfUkVBRFkpID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmIG9wdGlvbnMuaW5saW5lKSB7XG4gICAgICAgIHRoaXMudmlldyh0aGlzLmluZGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5vIGNvbmZsaWN0IHZpZXdlciBjbGFzcy5cbiAgICAgKiBAcmV0dXJucyB7Vmlld2VyfSBUaGUgdmlld2VyIGNsYXNzLlxuICAgICAqL1xuICB9XSwgW3tcbiAgICBrZXk6IFwibm9Db25mbGljdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgd2luZG93LlZpZXdlciA9IEFub3RoZXJWaWV3ZXI7XG4gICAgICByZXR1cm4gVmlld2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG5ldyBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGVmYXVsdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGVmYXVsdHMob3B0aW9ucykge1xuICAgICAgYXNzaWduKERFRkFVTFRTLCBpc1BsYWluT2JqZWN0KG9wdGlvbnMpICYmIG9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmlld2VyO1xufSgpO1xuYXNzaWduKFZpZXdlci5wcm90b3R5cGUsIHJlbmRlciwgZXZlbnRzLCBoYW5kbGVycywgbWV0aG9kcywgb3RoZXJzKTtcblxuZXhwb3J0IHsgVmlld2VyIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/viewerjs/dist/viewer.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/viewerjs/dist/viewer.css":
/*!***********************************************!*\
  !*** ./node_modules/viewerjs/dist/viewer.css ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"8cc334ada7b8\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlld2VyanMvZGlzdC92aWV3ZXIuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2FsbGVyeS1hcHAvLi9ub2RlX21vZHVsZXMvdmlld2VyanMvZGlzdC92aWV3ZXIuY3NzP2MxMGUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI4Y2MzMzRhZGE3YjhcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/viewerjs/dist/viewer.css\n");

/***/ })

};
;